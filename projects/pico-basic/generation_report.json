{
  "success": 18,
  "failed": 0,
  "skipped": 0,
  "total": 18,
  "chapters": [
    {
      "success": true,
      "chapter_id": "chapter01",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter01.md",
      "content": "# 피코야, 반가워! - 하드웨어 살펴보기\n\n> **Part 1**: 피코와 첫 만남 | ⏱️ **30분**\n\n---\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 라즈베리파이 피코가 무엇인지 설명할 수 있다\n- [ ] 피코 보드의 주요 부품(USB, LED, 핀)의 역할을 말할 수 있다\n- [ ] 피코를 컴퓨터에 안전하게 연결할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n여러분이 레고 블록으로 무언가를 만들기 전에 각 블록이 어떤 역할을 하는지 알아야 하듯이, 피코로 프로젝트를 만들기 전에 이 작은 보드가 어떻게 생겼고 각 부분이 무슨 일을 하는지 알아야 해요.\n\n\"이 USB 포트는 왜 여기 있지?\", \"이 작은 버튼은 뭐지?\", \"옆에 늘어선 구멍들은 뭐야?\"\n\n이런 궁금증을 해결하고 나면, 앞으로 LED를 켜고, 센서를 연결하고, 인터넷에 연결하는 모든 과정이 훨씬 쉬워집니다!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 라즈베리파이 피코란?\n\n1. **비유로 시작**: \"피코는 마치 **아주 작은 컴퓨터**와 같아요. 우리가 쓰는 컴퓨터처럼 프로그램을 실행할 수 있지만, 키보드나 모니터 대신 LED, 센서, 모터 같은 것들을 연결해서 사용해요.\"\n\n2. **정확한 정의**: \"라즈베리파이 피코(Raspberry Pi Pico)는 **마이크로컨트롤러 보드**입니다. 우리가 작성한 코드를 실행해서 전자 부품들을 제어하는 역할을 해요.\"\n\n3. **예시로 확인**: \"스마트폰이 앱을 실행하듯, 피코는 우리가 작성한 코드를 실행해요. 예를 들어 '버튼을 누르면 LED를 켜라'라는 코드를 넣으면, 피코가 24시간 그 일을 해줍니다!\"\n\n**쉽게 말하면**: 피코는 전자부품들의 두뇌 역할을 하는 초소형 컴퓨터예요! 🧠\n\n---\n\n### 개념 2: 피코 보드의 주요 부품\n\n피코 보드를 손에 들고 직접 살펴볼까요?\n\n```mermaid\nflowchart TB\n    subgraph PICO[\"🔲 라즈베리파이 피코 보드\"]\n        direction TB\n        USB[\"🔌 USB 포트\"]\n        BOOTSEL[\"⚪ BOOTSEL 버튼\"]\n        LED[\"💡 내장 LED\"]\n        CHIP[\"🧠 RP2040 칩\"]\n        PINS[\"📍 GPIO 핀들\"]\n    end\n    \n    USB --> |\"전원 공급 & 코드 전송\"| CHIP\n    BOOTSEL --> |\"특수 모드 진입\"| CHIP\n    CHIP --> |\"제어 신호\"| LED\n    CHIP --> |\"입출력 제어\"| PINS\n    \n    style USB fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    style BOOTSEL fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    style LED fill:#e8f5e9,stroke:#388e3c,stroke-width:2px\n    style CHIP fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n    style PINS fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n```\n\n| 부품 | 위치 | 역할 |\n|------|------|------|\n| 🔌 **USB 포트** | 보드 한쪽 끝 | 컴퓨터 연결, 전원 공급, 코드 전송 |\n| ⚪ **BOOTSEL 버튼** | USB 포트 옆 | 특수 모드로 부팅 (처음 설정할 때 사용) |\n| 💡 **내장 LED** | 보드 중앙 | 테스트용, 코드가 잘 동작하는지 확인 |\n| 🧠 **RP2040 칩** | 보드 중앙 큰 칩 | 피코의 두뇌, 모든 계산 수행 |\n| 📍 **GPIO 핀** | 보드 양쪽 가장자리 | 센서, LED 등 외부 장치 연결 |\n\n**쉽게 말하면**: USB로 전원과 코드를 받고, 칩이 계산하고, 핀으로 외부 장치를 제어해요!\n\n---\n\n### 개념 3: GPIO 핀이란?\n\n1. **비유로 시작**: \"GPIO 핀은 피코의 **손가락**과 같아요. 손가락으로 버튼을 누르거나 물건을 집듯이, GPIO 핀으로 신호를 보내거나 받을 수 있어요.\"\n\n2. **정확한 정의**: \"GPIO는 General Purpose Input/Output의 약자로, **범용 입출력 핀**이라는 뜻이에요. 프로그램으로 이 핀들을 제어해서 전자부품과 소통해요.\"\n\n3. **예시로 확인**: \n   - 📤 **출력**: \"GP16 핀에 HIGH 신호를 보내면 LED가 켜져요\"\n   - 📥 **입력**: \"GP20 핀으로 버튼이 눌렸는지 확인할 수 있어요\"\n\n**쉽게 말하면**: GPIO 핀 = 피코와 외부 세계를 연결하는 통로!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 피코 보드 관찰하기\n\n**목표**: 실제 피코 보드를 손에 들고 각 부품의 위치를 확인해요.\n\n**해볼 것**:\n1. 키트에서 피코 보드를 꺼내세요\n2. USB 포트가 있는 쪽을 찾아보세요 (보드의 한쪽 끝에 있어요)\n3. USB 포트 바로 옆에 있는 작은 흰색 버튼(BOOTSEL)을 찾아보세요\n4. 보드 중앙의 작은 LED를 찾아보세요\n5. 보드 양쪽 가장자리에 늘어선 핀(구멍)들을 확인하세요\n\n**여기서 잠깐! 🤔**\n피코를 다룰 때는 **가장자리를 잡으세요**! 보드 중앙의 칩이나 금속 부분을 손으로 직접 만지면 정전기로 고장날 수 있어요.\n\n---\n\n### Step 2: 피코를 컴퓨터에 연결하기\n\n**목표**: USB 케이블로 피코를 컴퓨터에 안전하게 연결해요.\n\n**준비물**: \n- 라즈베리파이 피코\n- Micro USB 케이블\n\n**연결 순서**:\n\n```mermaid\nflowchart LR\n    A[\"1️⃣ 케이블 준비\"] --> B[\"2️⃣ BOOTSEL 누름\"]\n    B --> C[\"3️⃣ USB 연결\"]\n    C --> D[\"4️⃣ 버튼 떼기\"]\n    D --> E[\"5️⃣ 드라이브 확인\"]\n    \n    style A fill:#e3f2fd,stroke:#1976d2\n    style B fill:#fff3e0,stroke:#f57c00\n    style C fill:#e8f5e9,stroke:#388e3c\n    style D fill:#fce4ec,stroke:#c2185b\n    style E fill:#f3e5f5,stroke:#7b1fa2\n```\n\n1. **케이블 준비**: Micro USB 케이블의 작은 쪽이 피코에 연결됩니다\n2. **BOOTSEL 버튼 누르기**: 피코의 BOOTSEL 버튼을 **누른 상태로 유지**\n3. **USB 연결**: 버튼을 누른 채로 USB 케이블을 피코에 연결\n4. **컴퓨터 연결**: 케이블의 반대쪽을 컴퓨터 USB 포트에 연결\n5. **버튼 떼기**: 연결이 완료되면 BOOTSEL 버튼에서 손을 뗌\n\n**성공 확인**:\n- 컴퓨터에서 **RPI-RP2**라는 이름의 USB 드라이브가 나타나면 성공! 🎉\n\n**여기서 잠깐! 🤔**\nBOOTSEL 버튼을 누른 상태로 연결하는 건 **처음 한 번**만 필요해요. 나중에 MicroPython을 설치하고 나면, 그냥 연결만 하면 됩니다!\n\n---\n\n### Step 3: 연결 상태 확인하기\n\n**목표**: 피코가 컴퓨터에 제대로 인식되었는지 확인해요.\n\n**Windows에서 확인**:\n1. 파일 탐색기를 열어요\n2. \"내 PC\" 또는 \"이 PC\"를 클릭\n3. **RPI-RP2** 드라이브가 보이는지 확인\n\n**Mac에서 확인**:\n1. Finder를 열어요\n2. 왼쪽 사이드바에 **RPI-RP2**가 보이는지 확인\n\n```mermaid\nflowchart LR\n    subgraph 컴퓨터[\"💻 컴퓨터\"]\n        탐색기[\"📁 파일 탐색기\"]\n    end\n    \n    subgraph 드라이브[\"✅ 성공!\"]\n        RPI[\"📀 RPI-RP2\"]\n    end\n    \n    탐색기 --> RPI\n    \n    style 탐색기 fill:#e3f2fd,stroke:#1976d2\n    style RPI fill:#e8f5e9,stroke:#388e3c\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: BOOTSEL 버튼을 안 누르고 연결함\n\n**증상**: USB 드라이브(RPI-RP2)가 나타나지 않음\n\n**원인**: 피코가 일반 모드로 부팅되어서 드라이브로 인식되지 않음\n\n**해결**:\n1. USB 케이블을 뽑으세요\n2. BOOTSEL 버튼을 **먼저** 누르고\n3. **누른 상태로** USB를 다시 연결하세요\n4. 연결 후 버튼을 떼세요\n\n---\n\n### 실수 2: 충전 전용 케이블 사용\n\n**증상**: 피코에 전원은 들어오는 것 같은데(LED가 깜빡일 수 있음) 컴퓨터에서 인식 안 됨\n\n**원인**: 데이터 전송이 안 되는 충전 전용 케이블 사용\n\n**해결**:\n- **데이터 전송이 가능한** Micro USB 케이블을 사용하세요\n- 스마트폰 충전기에 포함된 케이블 중 일부는 충전만 됩니다\n- 키트에 포함된 케이블을 사용하면 확실해요!\n\n---\n\n### 실수 3: 보드를 잘못 잡아서 정전기 피해\n\n**증상**: 처음엔 됐는데 갑자기 피코가 인식이 안 됨\n\n**원인**: 손으로 칩이나 핀을 직접 만져서 정전기 피해 발생\n\n**해결**:\n- 항상 **보드의 가장자리**를 잡으세요\n- 금속 부분을 직접 만지지 마세요\n- 작업 전 금속 물체를 만져서 정전기를 빼는 것도 좋아요\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **피코의 역할은 무엇인가요?**\n\n2. **BOOTSEL 버튼은 언제 사용하나요?**\n\n3. **GPIO 핀의 역할을 한 문장으로 설명해보세요.**\n\n4. **피코를 컴퓨터에 연결했을 때, 성공적으로 인식되면 무엇이 나타나나요?**\n\n<details>\n<summary>정답 확인</summary>\n\n1. **피코의 역할**: 우리가 작성한 코드를 실행해서 LED, 센서, 모터 같은 전자부품을 제어하는 초소형 컴퓨터(마이크로컨트롤러)\n\n2. **BOOTSEL 버튼**: 피코를 특수 모드(부트 모드)로 부팅할 때 사용. 주로 처음 MicroPython을 설치하거나 펌웨어를 업데이트할 때 필요\n\n3. **GPIO 핀의 역할**: 피코와 외부 전자부품(센서, LED 등)을 연결해서 신호를 주고받는 통로\n\n4. **성공 시 나타나는 것**: RPI-RP2라는 이름의 USB 드라이브\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 핀 번호 찾기 👀\n피코 보드를 자세히 보면 각 핀 옆에 작은 글씨로 번호가 적혀 있어요. GP0, GP1, GP2... 이런 식으로요. **GP16이 어디 있는지** 찾아보세요!\n\n### 도전 2: 피코 vs 아두이노 검색하기 🔍\n\"라즈베리파이 피코 vs 아두이노\"를 검색해서 둘의 차이점을 3가지 찾아보세요. 어떤 점이 다른가요?\n\n### 도전 3: 피코로 만든 프로젝트 구경하기 ⭐\nYouTube에서 \"Raspberry Pi Pico project\"를 검색해보세요. 어떤 멋진 프로젝트들이 있나요? 가장 만들어보고 싶은 것을 하나 골라보세요!\n\n---\n\n## 🔗 다음 장으로\n\n축하해요! 🎉 이번 장에서 우리는:\n- ✅ 피코가 무엇인지 알았어요\n- ✅ 보드의 각 부품(USB, BOOTSEL, LED, 칩, 핀)이 무슨 역할을 하는지 배웠어요\n- ✅ 피코를 컴퓨터에 안전하게 연결하는 방법을 익혔어요\n\n**다음 장**에서는 피코에 **MicroPython**을 설치하고, 드디어 **첫 번째 코드**를 실행해볼 거예요. \"Hello, World!\"를 출력하고, 피코의 내장 LED를 깜빡이게 만들어봐요! \n\n우리의 피코에 생명을 불어넣을 준비 되셨나요? 💪",
      "tokens_used": 18131,
      "input_tokens": 13426,
      "output_tokens": 4705
    },
    {
      "success": true,
      "chapter_id": "chapter02",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter02.md",
      "content": "# 📘 Chapter 02: 개발 환경 설정 - Thonny 설치하기\n\n> **Part 1**: 피코와 첫 만남 | ⏱️ 약 30분\n\n---\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] Thonny IDE를 다운로드하고 설치할 수 있다\n- [ ] 피코를 컴퓨터에 연결하고 Thonny에서 인식시킬 수 있다\n- [ ] MicroPython 펌웨어를 피코에 설치할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n코드를 작성하려면 **편집기**가 필요해요. 메모장으로도 코드를 쓸 수 있지만, 그건 마치 맨손으로 못을 박는 것과 같아요. 🔨\n\n**Thonny**는 파이썬 초보자를 위해 만들어진 편집기예요. 특히 피코와 찰떡궁합인데, 이유가 있어요:\n\n- 🔌 **바로 연결**: USB만 꽂으면 피코를 자동 인식\n- ▶️ **즉시 실행**: 버튼 하나로 코드를 피코에 전송하고 실행\n- 🐛 **친절한 오류**: 뭐가 잘못됐는지 쉽게 알려줌\n\n그리고 피코는 처음 상태에서는 MicroPython을 이해하지 못해요. 마치 새 스마트폰에 운영체제를 설치하는 것처럼, 피코에도 **MicroPython 펌웨어**를 설치해야 우리가 작성한 코드를 이해할 수 있어요.\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: IDE (통합 개발 환경)\n\n1. **비유로 시작**: IDE는 마치 **요리사의 주방**과 같아요. 칼, 도마, 가스레인지가 한 곳에 모여 있으면 요리하기 편하죠? IDE도 코드 작성, 실행, 디버깅을 한 곳에서 할 수 있게 해줘요.\n\n2. **정확한 정의**: IDE(Integrated Development Environment)는 코드 편집기, 실행 환경, 오류 검사 도구가 통합된 프로그램이에요.\n\n3. **예시로 확인**: Thonny에서 코드를 작성하고 → 실행 버튼을 누르면 → 결과가 바로 아래에 표시돼요.\n\n**쉽게 말하면**: 코딩에 필요한 모든 도구가 담긴 올인원 프로그램! 🧰\n\n---\n\n### 개념 2: 펌웨어 (Firmware)\n\n1. **비유로 시작**: 펌웨어는 마치 **사람의 본능**과 같아요. 심장이 뛰고 숨을 쉬는 건 배우지 않아도 하잖아요? 펌웨어는 하드웨어가 \"기본적으로 할 줄 아는 것\"을 담당해요.\n\n2. **정확한 정의**: 펌웨어는 하드웨어에 내장되어 기본 동작을 제어하는 소프트웨어예요. 피코의 MicroPython 펌웨어는 \"파이썬 코드를 이해하는 능력\"을 심어줘요.\n\n3. **예시로 확인**: 펌웨어 설치 전에는 피코가 `print(\"안녕\")`를 몰라요. 설치 후에는 이해하고 실행해요!\n\n**쉽게 말하면**: 피코에게 \"파이썬 말하는 법\"을 가르치는 거예요! 🗣️\n\n---\n\n## 🔨 따라하기\n\n### Step 1: Thonny 다운로드 및 설치\n\n**목표**: 컴퓨터에 Thonny를 설치해요.\n\n**1️⃣ 다운로드 사이트 접속**\n\n웹 브라우저에서 **thonny.org**에 접속해요.\n\n```mermaid\nflowchart LR\n    A[🌐 브라우저 열기] --> B[📍 thonny.org 접속] --> C[💾 다운로드]\n    style A fill:#e3f2fd,stroke:#1976d2\n    style B fill:#fff3e0,stroke:#f57c00\n    style C fill:#e8f5e9,stroke:#388e3c\n```\n\n**2️⃣ 운영체제에 맞는 버전 다운로드**\n\n| 운영체제 | 클릭할 버튼 |\n|---------|------------|\n| Windows | 오른쪽 상단 **Windows** |\n| Mac | 오른쪽 상단 **Mac** |\n\n**3️⃣ 설치 진행**\n\n- 다운로드된 파일 실행\n- **Next** → **Next** → **Install** → **Finish**\n- 기본 설정 그대로 진행하면 OK!\n\n**여기서 잠깐! 🤔**\n\n> 설치 중 \"이 앱이 디바이스를 변경할 수 있도록 허용하시겠습니까?\" 라고 물으면 **예**를 클릭하세요. 정상적인 과정이에요!\n\n---\n\n### Step 2: 피코를 BOOTSEL 모드로 연결하기\n\n**목표**: 피코를 펌웨어 설치 모드로 컴퓨터에 연결해요.\n\n**1️⃣ BOOTSEL 버튼 찾기**\n\n피코 보드에서 **BOOTSEL**이라고 적힌 작은 버튼을 찾아요. 보드 중앙 근처에 있어요.\n\n```mermaid\nflowchart TB\n    subgraph 피코보드[📟 피코 보드]\n        direction TB\n        USB[🔌 USB 포트]\n        BTN[⚪ BOOTSEL 버튼]\n        LED[💡 LED]\n    end\n    style 피코보드 fill:#f5f5f5,stroke:#424242\n    style USB fill:#e3f2fd,stroke:#1976d2\n    style BTN fill:#ffeb3b,stroke:#f57f17\n    style LED fill:#c8e6c9,stroke:#388e3c\n```\n\n**2️⃣ 버튼 누른 채로 USB 연결**\n\n이 순서가 중요해요!\n\n1. BOOTSEL 버튼을 **꾹 누른 상태**로\n2. USB 케이블을 컴퓨터에 연결\n3. 2초 정도 기다린 후 버튼에서 손 떼기\n\n**3️⃣ 확인하기**\n\n성공하면 컴퓨터에 **RPI-RP2**라는 USB 드라이브가 나타나요!\n\n| 상태 | 의미 |\n|------|------|\n| ✅ RPI-RP2 드라이브 보임 | 성공! 다음 단계로 |\n| ❌ 드라이브 안 보임 | USB 뽑고 다시 시도 |\n\n**여기서 잠깐! 🤔**\n\n> BOOTSEL 모드는 \"나 지금 새 운영체제 받을 준비됐어!\"라고 피코가 말하는 거예요. 일반 연결과 다른 특별한 모드랍니다.\n\n---\n\n### Step 3: Thonny에서 MicroPython 펌웨어 설치하기\n\n**목표**: Thonny를 사용해 피코에 MicroPython을 설치해요.\n\n**1️⃣ Thonny 실행**\n\n설치한 Thonny를 실행해요. 처음 실행하면 언어 선택 화면이 나와요.\n- **Language**: 한국어 선택해도 좋아요!\n\n**2️⃣ 인터프리터 설정 열기**\n\n메뉴에서: **도구(Tools)** → **옵션(Options)** → **인터프리터(Interpreter)** 탭\n\n**3️⃣ MicroPython (Raspberry Pi Pico) 선택**\n\n```mermaid\nflowchart TD\n    A[🔧 도구 메뉴] --> B[⚙️ 옵션]\n    B --> C[🐍 인터프리터 탭]\n    C --> D[📋 드롭다운에서 선택]\n    D --> E[\"MicroPython (RP2040)\"]\n    style A fill:#e3f2fd,stroke:#1976d2\n    style B fill:#fff3e0,stroke:#f57c00\n    style C fill:#e8f5e9,stroke:#388e3c\n    style D fill:#fce4ec,stroke:#c2185b\n    style E fill:#f3e5f5,stroke:#7b1fa2\n```\n\n- 드롭다운에서 **MicroPython (Raspberry Pi Pico)** 또는 **MicroPython (RP2040)** 선택\n\n**4️⃣ 펌웨어 설치**\n\n- 오른쪽 아래 **\"Install or update MicroPython\"** 링크 클릭\n- **Target volume**: RPI-RP2 선택\n- **MicroPython variant**: Raspberry Pi Pico 2 W (WiFi 버전이면) 선택\n- **Install** 클릭!\n\n**5️⃣ 설치 완료 확인**\n\n설치가 끝나면:\n- RPI-RP2 드라이브가 사라짐 (정상!)\n- Thonny 하단 Shell에 `>>>` 표시가 나타남\n\n**실행 결과**:\n```\nMicroPython v1.22.0 on 2024-01-01; Raspberry Pi Pico 2 W\nType \"help()\" for more information.\n>>> \n```\n\n**여기서 잠깐! 🤔**\n\n> `>>>` 이 기호는 \"나 준비됐어, 명령 줘!\"라는 뜻이에요. 이게 보이면 피코와 대화할 준비 완료! 🎉\n\n---\n\n## 📝 연결 확인 테스트\n\n펌웨어가 잘 설치됐는지 간단히 테스트해볼까요?\n\nThonny 하단의 **Shell** 창에서 `>>>` 옆에 직접 타이핑해보세요:\n\n```python\n>>> print(\"안녕, 피코!\")\n```\n\n**실행 결과**:\n```\n안녕, 피코!\n>>> \n```\n\n축하해요! 🎊 피코가 여러분의 말을 이해했어요!\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: BOOTSEL 버튼 타이밍 실수\n\n**증상**: RPI-RP2 드라이브가 안 나타남\n\n**원인**: 버튼을 누르기 전에 USB를 먼저 연결했거나, 버튼을 너무 빨리 놓음\n\n**해결**:\n```\n❌ 잘못된 순서\n1. USB 연결 → 2. BOOTSEL 누름\n\n✅ 올바른 순서  \n1. BOOTSEL 꾹 누름 → 2. USB 연결 → 3. 2초 후 버튼 놓음\n```\n\n---\n\n### 실수 2: Thonny에서 피코가 인식 안 됨\n\n**증상**: Shell에 `>>>` 대신 에러 메시지\n\n**원인**: 인터프리터 설정이 안 됐거나, 포트 선택이 잘못됨\n\n**해결**:\n1. **도구** → **옵션** → **인터프리터**\n2. **MicroPython (Raspberry Pi Pico)** 선택 확인\n3. 포트가 **< Try to detect port automatically >** 인지 확인\n4. USB 케이블을 뽑았다가 다시 연결\n\n---\n\n### 실수 3: 펌웨어 설치 중 Target volume 선택 불가\n\n**증상**: Target volume 드롭다운이 비어있음\n\n**원인**: BOOTSEL 모드로 연결되지 않음\n\n**해결**:\n1. Thonny 닫기\n2. USB 케이블 분리\n3. Step 2 다시 진행 (BOOTSEL 누른 채 연결)\n4. Thonny 다시 열기\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **Thonny**는 어떤 프로그램인가요?\n\n2. 피코에 **펌웨어**를 설치하는 이유는 무엇인가요?\n\n3. **BOOTSEL 모드**로 연결하려면 어떤 순서로 해야 하나요?\n\n<details>\n<summary>정답 확인</summary>\n\n1. 파이썬 코드를 작성하고 실행할 수 있는 통합 개발 환경(IDE)이에요. 특히 피코와 바로 연결해서 사용할 수 있어 편리해요.\n\n2. 피코가 MicroPython 코드를 이해하고 실행할 수 있게 하려면 MicroPython 펌웨어가 필요해요. 마치 스마트폰에 운영체제를 설치하는 것과 같아요.\n\n3. BOOTSEL 버튼을 꾹 누른 상태에서 → USB 연결 → 2초 후 버튼 놓기\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: Shell에서 계산기처럼 사용하기 ⭐\nThonny Shell에서 이것들을 입력해보세요:\n```python\n>>> 1 + 1\n>>> 100 * 5\n>>> \"파이썬\" * 3\n```\n결과가 어떻게 나오나요?\n\n### 도전 2: 피코 정보 확인하기 ⭐⭐\nShell에 이걸 입력해보세요:\n```python\n>>> import sys\n>>> sys.implementation\n```\n여러분의 피코 정보가 나와요!\n\n### 도전 3: 도움말 살펴보기 ⭐⭐⭐\n```python\n>>> help()\n```\nMicroPython이 제공하는 도움말을 탐험해보세요!\n\n---\n\n## 🔗 다음 장으로\n\n**축하해요!** 🎉 이번 장에서 우리는:\n- ✅ Thonny IDE를 설치했고\n- ✅ 피코를 컴퓨터에 연결했고  \n- ✅ MicroPython 펌웨어를 설치했어요\n\n이제 피코가 파이썬을 이해할 수 있게 됐어요!\n\n**다음 장**에서는 드디어 첫 번째 프로그램을 작성해볼 거예요. 피코에게 `\"Hello, World!\"`를 말하게 해봅시다! 🚀\n\n---\n\n> 📌 **환경 설정 완료 체크리스트**\n> \n> - [ ] Thonny 설치됨\n> - [ ] 피코 연결됨 (Shell에 `>>>` 보임)\n> - [ ] `print(\"테스트\")` 실행 성공\n> \n> 모두 체크했다면 다음 장으로 GO! 🏃‍♂️",
      "tokens_used": 17957,
      "input_tokens": 13367,
      "output_tokens": 4590
    },
    {
      "success": true,
      "chapter_id": "chapter03",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter03.md",
      "content": "# Chapter 03: Hello, Pico! - 첫 번째 프로그램 실행\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] Thonny에서 MicroPython 코드를 작성하고 실행할 수 있다\n- [ ] print() 함수로 원하는 메시지를 출력할 수 있다\n- [ ] 피코의 내장 LED를 켜고 끌 수 있다\n- [ ] 간단한 LED 깜빡임 프로그램을 만들 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n프로그래밍을 배울 때 가장 먼저 하는 일이 뭔지 아세요? 바로 **\"Hello, World!\"**를 화면에 출력하는 거예요. 1970년대부터 지금까지, 전 세계 모든 프로그래머가 이렇게 첫 걸음을 뗐답니다.\n\n왜 하필 \"Hello, World!\"일까요? \n\n- ✅ 코드가 제대로 작동하는지 **가장 빠르게 확인**할 수 있어요\n- ✅ 복잡한 문법 없이 **성공의 기쁨**을 맛볼 수 있어요\n- ✅ \"내가 컴퓨터에게 명령했고, 컴퓨터가 응답했다!\"는 **첫 대화**예요\n\n그리고 피지컬 컴퓨팅에서는 한 단계 더 나아가요. 화면에 글자만 출력하는 게 아니라, **실제로 LED가 켜지는 걸 눈으로 확인**하죠. 코드 한 줄로 전구가 켜지는 순간, \"와, 내가 진짜 하드웨어를 제어하고 있구나!\"라는 짜릿한 경험을 하게 될 거예요!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: print() 함수 - 컴퓨터에게 말 걸기\n\n1. **비유로 시작**: print()는 마치 **확성기**와 같아요. 여러분이 하고 싶은 말을 컴퓨터 화면에 크게 출력해주죠.\n\n2. **정확한 정의**: print()는 괄호 안의 내용을 화면(Shell)에 출력하는 파이썬 내장 함수입니다.\n\n3. **예시로 확인**: \n```python\nprint(\"안녕하세요!\")  # 화면에 \"안녕하세요!\" 출력\nprint(123)           # 숫자 123 출력\nprint(1 + 2)         # 계산 결과 3 출력\n```\n\n**쉽게 말하면**: print()는 \"이걸 화면에 보여줘!\"라고 말하는 명령어예요.\n\n---\n\n### 개념 2: GPIO와 Pin - 피코의 손가락\n\n1. **비유로 시작**: GPIO 핀은 마치 피코의 **손가락**이에요. 이 손가락으로 LED를 누르면(전기를 보내면) 불이 켜지고, 떼면 꺼지죠.\n\n2. **정확한 정의**: GPIO(General Purpose Input/Output)는 전기 신호를 내보내거나(출력) 받아들이는(입력) 다용도 핀이에요. Pin 클래스는 이 핀을 제어하는 도구입니다.\n\n3. **예시로 확인**:\n\n```mermaid\nflowchart LR\n    A[🧠 피코 코드] --> B[📍 GPIO 핀]\n    B --> C[💡 LED]\n    \n    style A fill:#e3f2fd,stroke:#1976d2\n    style B fill:#fff3e0,stroke:#f57c00\n    style C fill:#e8f5e9,stroke:#388e3c\n```\n\n**쉽게 말하면**: Pin은 피코가 외부 장치(LED, 센서 등)와 대화하는 통로예요.\n\n---\n\n### 개념 3: 내장 LED - 첫 번째 친구\n\n1. **비유로 시작**: 피코에는 **작은 초록색 LED**가 이미 붙어 있어요. 마치 피코가 \"나 여기 있어!\"라고 신호를 보내는 **눈**과 같죠.\n\n2. **정확한 정의**: Pico 2W에는 무선 칩에 연결된 내장 LED가 있어서, 별도 부품 없이도 바로 불을 켜볼 수 있습니다.\n\n3. **예시로 확인**: `Pin(\"LED\", Pin.OUT)`으로 내장 LED를 제어할 수 있어요.\n\n**쉽게 말하면**: 피코를 샀으면 LED도 하나 공짜! 바로 실습해볼 수 있어요.\n\n---\n\n## 🔨 따라하기\n\n### Step 1: Hello, Pico! 출력하기\n\n**목표**: 화면에 첫 번째 메시지를 출력해요.\n\n**코드**:\n```python\n# === WHAT: 화면에 인사말 출력하기 ===\n# 프로그래밍의 전통! 첫 프로그램은 항상 인사로 시작해요\n\n# --- WHY: 왜 필요한지 ---\n# 코드가 제대로 실행되는지 가장 빠르게 확인할 수 있어요\n\n# HOW: 어떻게 동작하는지\nprint(\"Hello, Pico!\")  # 괄호 안의 문자열을 Shell에 출력\n```\n\n**실행 방법**:\n1. Thonny에서 위 코드를 입력해요\n2. 초록색 ▶️ 실행 버튼을 클릭해요\n3. 아래 Shell 창을 확인해요!\n\n**실행 결과**:\n```\nHello, Pico!\n```\n\n**여기서 잠깐! 🤔**\n\n큰따옴표(`\"`) 안에 있는 글자는 **문자열(string)**이라고 불러요. 컴퓨터에게 \"이건 그냥 글자야, 명령어가 아니야\"라고 알려주는 표시죠.\n\n---\n\n### Step 2: 다양한 메시지 출력하기\n\n**목표**: print()로 여러 가지를 출력해봐요.\n\n**코드**:\n```python\n# === WHAT: 다양한 내용 출력하기 ===\n# 문자, 숫자, 계산 결과 모두 출력 가능해요!\n\n# --- WHY: 왜 필요한지 ---\n# 나중에 센서 값이나 상태를 확인할 때 print()를 많이 써요\n\n# HOW: 어떻게 동작하는지\nprint(\"안녕하세요, 저는 피코예요!\")  # 한글도 OK\nprint(\"1 + 1 =\", 1 + 1)              # 여러 개를 쉼표로 연결\nprint(\"=\" * 20)                       # 문자 반복 (구분선 만들기)\n```\n\n**실행 결과**:\n```\n안녕하세요, 저는 피코예요!\n1 + 1 = 2\n====================\n```\n\n**여기서 잠깐! 🤔**\n\n`print()` 안에서 쉼표(`,`)로 여러 값을 연결하면 자동으로 띄어쓰기가 들어가요. 편리하죠?\n\n---\n\n### Step 3: 내장 LED 켜기\n\n**목표**: 드디어 하드웨어를 제어해요! LED를 켜봅시다.\n\n**코드**:\n```python\n# === WHAT: 피코 내장 LED 켜기 ===\n# 코드 한 줄로 실제 불이 켜져요!\n\n# --- WHY: 왜 필요한지 ---\n# 피코가 제대로 연결됐는지 확인하고, 하드웨어 제어의 첫걸음!\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin    # Pin 클래스 가져오기 (GPIO 제어용)\n\nled = Pin(\"LED\", Pin.OUT)  # 내장 LED를 출력 모드로 설정\nled.on()                   # LED 켜기!\n\nprint(\"LED가 켜졌어요! 피코를 확인해보세요 👀\")\n```\n\n**실행 방법**:\n1. 코드를 입력하고 ▶️ 실행\n2. **피코 보드를 직접 봐주세요!**\n3. 작은 초록색 LED가 켜져 있나요? 🎉\n\n**실행 결과**:\n```\nLED가 켜졌어요! 피코를 확인해보세요 👀\n```\n+ 피코의 초록색 LED가 켜짐!\n\n**여기서 잠깐! 🤔**\n\n`from machine import Pin`은 \"machine이라는 도구상자에서 Pin이라는 도구를 꺼내올게\"라는 뜻이에요. MicroPython에서 하드웨어를 제어할 때 항상 필요해요.\n\n---\n\n### Step 4: LED 끄기\n\n**목표**: 켠 LED를 꺼봐요.\n\n**코드**:\n```python\n# === WHAT: LED 끄기 ===\n# on()의 반대는 off()!\n\nfrom machine import Pin\n\nled = Pin(\"LED\", Pin.OUT)\nled.off()                  # LED 끄기\n\nprint(\"LED가 꺼졌어요!\")\n```\n\n**실행 결과**:\n```\nLED가 꺼졌어요!\n```\n+ 피코의 LED가 꺼짐\n\n---\n\n### Step 5: LED 깜빡이기 (완성!)\n\n**목표**: LED를 켰다 껐다 반복해서 깜빡이게 만들어요.\n\n**코드**:\n```python\n# === WHAT: LED 깜빡이기 ===\n# 켜고 → 잠깐 기다리고 → 끄고 → 잠깐 기다리고... 반복!\n\n# --- WHY: 왜 필요한지 ---\n# 이게 바로 피지컬 컴퓨팅의 기본! 신호등, 비상등 모두 이 원리예요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin    # 핀 제어\nimport time                # 시간 관련 기능 (대기)\n\nled = Pin(\"LED\", Pin.OUT)  # LED 설정\n\n# 5번 깜빡이기\nfor i in range(5):         # 0, 1, 2, 3, 4 (총 5번)\n    led.on()               # 켜기\n    print(\"💡 ON\")\n    time.sleep(0.5)        # 0.5초 대기\n    \n    led.off()              # 끄기\n    print(\"⚫ OFF\")\n    time.sleep(0.5)        # 0.5초 대기\n\nprint(\"깜빡이기 완료! 🎉\")\n```\n\n**실행 결과**:\n```\n💡 ON\n⚫ OFF\n💡 ON\n⚫ OFF\n💡 ON\n⚫ OFF\n💡 ON\n⚫ OFF\n💡 ON\n⚫ OFF\n깜빡이기 완료! 🎉\n```\n+ LED가 5번 깜빡임!\n\n**여기서 잠깐! 🤔**\n\n`time.sleep(0.5)`는 \"0.5초 동안 쉬어!\"라는 명령이에요. 이게 없으면 LED가 너무 빨리 켜졌다 꺼져서 눈에 안 보여요.\n\n---\n\n## 📝 전체 코드\n\n```python\n# === Hello, Pico! - LED 깜빡이기 완성본 ===\n# 피지컬 컴퓨팅 첫 번째 프로그램\n# 내장 LED를 5번 깜빡입니다\n\nfrom machine import Pin    # GPIO 핀 제어\nimport time                # 시간 관련 함수\n\n# LED 설정\nled = Pin(\"LED\", Pin.OUT)  # 내장 LED를 출력 모드로\n\n# 시작 메시지\nprint(\"=\" * 30)\nprint(\"🚀 Hello, Pico!\")\nprint(\"LED 깜빡이기를 시작합니다\")\nprint(\"=\" * 30)\n\n# 5번 깜빡이기\nfor i in range(5):\n    led.on()\n    print(f\"💡 {i+1}번째 ON\")\n    time.sleep(0.5)\n    \n    led.off()\n    print(f\"⚫ {i+1}번째 OFF\")\n    time.sleep(0.5)\n\n# 종료 메시지\nprint(\"=\" * 30)\nprint(\"✅ 완료! 첫 프로그램 성공!\")\nprint(\"=\" * 30)\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 따옴표를 빼먹음\n\n**증상**: \n```\nSyntaxError: invalid syntax\n```\n\n**원인**: 문자열을 따옴표로 감싸지 않았어요.\n\n**해결**:\n```python\n# ❌ 잘못된 코드\nprint(Hello, Pico!)\n\n# ✅ 올바른 코드\nprint(\"Hello, Pico!\")\n```\n\n---\n\n### 실수 2: Pin 이름을 잘못 씀\n\n**증상**: \n```\nValueError: invalid pin\n```\n\n**원인**: 내장 LED의 이름은 정확히 `\"LED\"`여야 해요.\n\n**해결**:\n```python\n# ❌ 잘못된 코드\nled = Pin(\"led\", Pin.OUT)      # 소문자\nled = Pin(\"LED내장\", Pin.OUT)  # 이상한 이름\n\n# ✅ 올바른 코드\nled = Pin(\"LED\", Pin.OUT)      # 정확히 \"LED\"\n```\n\n---\n\n### 실수 3: import를 안 함\n\n**증상**: \n```\nNameError: name 'Pin' is not defined\n```\n\n**원인**: Pin을 사용하려면 먼저 불러와야(import) 해요.\n\n**해결**:\n```python\n# ❌ 잘못된 코드 (import 없음)\nled = Pin(\"LED\", Pin.OUT)\n\n# ✅ 올바른 코드\nfrom machine import Pin        # 이 줄이 꼭 필요!\nled = Pin(\"LED\", Pin.OUT)\n```\n\n---\n\n### 실수 4: sleep에 시간을 안 씀\n\n**증상**: LED가 너무 빨리 깜빡여서 안 보임 (또는 에러)\n\n**원인**: sleep() 함수에는 대기 시간(초)을 넣어야 해요.\n\n**해결**:\n```python\n# ❌ 잘못된 코드\ntime.sleep()       # 시간이 없음!\n\n# ✅ 올바른 코드\ntime.sleep(0.5)    # 0.5초 대기\ntime.sleep(1)      # 1초 대기\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **print() 함수는 무엇을 하나요?**\n\n2. **LED를 켜는 명령어와 끄는 명령어는 각각 무엇인가요?**\n\n3. **`time.sleep(2)`는 몇 초를 기다리나요?**\n\n4. **왜 `from machine import Pin`을 코드 맨 위에 쓰나요?**\n\n<details>\n<summary>정답 확인</summary>\n\n1. 괄호 안의 내용을 화면(Shell)에 출력합니다.\n\n2. `led.on()`으로 켜고, `led.off()`로 끕니다.\n\n3. 2초를 기다립니다. (괄호 안의 숫자가 초 단위)\n\n4. Pin 클래스를 사용하려면 먼저 machine 모듈에서 가져와야 하기 때문입니다. import 없이는 Pin이 뭔지 파이썬이 몰라요!\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 나만의 인사말 출력하기\nprint()를 사용해서 자신만의 인사말을 3줄 이상 출력해보세요.\n\n```python\n# 예시 시작점\nprint(\"=\" * 30)\nprint(\"여기에 나만의 메시지!\")\n# ... 더 추가해보세요!\n```\n\n---\n\n### 도전 2: 깜빡임 속도 바꾸기\n`time.sleep()` 안의 숫자를 바꿔서 LED가 더 빠르게 또는 느리게 깜빡이게 해보세요.\n\n- 빠르게: `time.sleep(0.1)`\n- 느리게: `time.sleep(1.5)`\n\n어떤 속도가 가장 보기 좋은지 실험해보세요!\n\n---\n\n### 도전 3: SOS 신호 만들기 ⭐\n\n모스 부호에서 SOS는 `··· --- ···` 입니다.\n- 짧은 신호(·): LED 0.2초 켜기\n- 긴 신호(-): LED 0.6초 켜기\n- 신호 사이: 0.2초 끄기\n\n힌트:\n```python\n# S = 짧게 3번\nfor i in range(3):\n    led.on()\n    time.sleep(0.2)  # 짧게\n    led.off()\n    time.sleep(0.2)\n\n# O = 길게 3번 (직접 완성해보세요!)\n\n# S = 짧게 3번 (위와 같음)\n```\n\n---\n\n## 🔗 다음 장으로\n\n축하합니다! 🎉 \n\n오늘 여러분은:\n- ✅ 첫 MicroPython 코드를 작성하고 실행했어요\n- ✅ print()로 화면에 메시지를 출력했어요  \n- ✅ **실제 LED를 코드로 제어**했어요!\n\n이게 바로 피지컬 컴퓨팅의 시작이에요. 코드가 화면에서 끝나는 게 아니라, 실제 세상에 영향을 주죠.\n\n**다음 장**에서는 LED를 더 다양하게 제어해볼 거예요. 외부 LED를 연결하고, 여러 개의 LED를 동시에 제어하는 방법을 배웁니다. 나만의 LED 패턴을 만들어볼 준비 되셨나요? 💡✨",
      "tokens_used": 18904,
      "input_tokens": 13363,
      "output_tokens": 5541
    },
    {
      "success": true,
      "chapter_id": "chapter04",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter04.md",
      "content": "# Chapter 04: 브레드보드와 친해지기 - LED 회로 구성\n\n> **Part 2**: 빛으로 말하기 - LED 제어\n\n---\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 브레드보드의 구조와 내부 연결 원리를 설명할 수 있다\n- [ ] LED의 극성(+/-)을 구분하고 올바르게 연결할 수 있다\n- [ ] 저항의 역할을 이해하고 LED 보호 회로를 구성할 수 있다\n- [ ] 회로도를 보고 브레드보드에 동일한 회로를 구성할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n지금까지는 피코에 내장된 LED만 제어했어요. 하지만 실제 프로젝트에서는 **외부 부품**을 연결해야 합니다. 무드등, 알림 장치, 로봇 눈... 모두 외부 LED가 필요하죠!\n\n브레드보드는 **납땜 없이** 부품을 연결할 수 있는 마법의 보드예요. 레고 블록처럼 꽂았다 뺐다 할 수 있어서, 실험하고 수정하기 딱 좋습니다.\n\n이번 장을 마치면, 여러분은 직접 LED 회로를 구성하고 코드로 제어할 수 있게 됩니다! 🎉\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 브레드보드의 구조\n\n1. **비유로 시작**: \"브레드보드는 마치 **아파트 복도**와 같아요. 같은 층(가로줄)에 사는 사람들은 서로 연결되어 있고, 다른 층과는 분리되어 있죠.\"\n\n2. **정확한 정의**: \"브레드보드는 내부에 금속 클립이 있어서 특정 구멍들이 전기적으로 연결되어 있는 실험용 기판입니다.\"\n\n3. **예시로 확인**: \"예를 들어, 1번 줄의 a-b-c-d-e 구멍은 모두 연결되어 있어요. 여기에 부품 다리들을 꽂으면 자동으로 연결됩니다!\"\n\n```mermaid\nflowchart TB\n    subgraph 브레드보드[\"🔌 브레드보드 연결 구조\"]\n        direction TB\n        subgraph 전원[\"⚡ 전원 레일 (세로 연결)\"]\n            P1[\"+ + + + +\"]\n            P2[\"- - - - -\"]\n        end\n        subgraph 중앙[\"📍 중앙 영역 (가로 연결)\"]\n            R1[\"a b c d e ← 연결됨\"]\n            GAP[\"--- 홈 ---\"]\n            R2[\"f g h i j ← 연결됨\"]\n        end\n    end\n    \n    style 브레드보드 fill:#f5f5f5,stroke:#424242\n    style 전원 fill:#ffcdd2,stroke:#c62828\n    style 중앙 fill:#e3f2fd,stroke:#1565c0\n```\n\n**쉽게 말하면**: 가로줄은 연결되고, 홈을 기준으로 위아래는 분리됩니다!\n\n---\n\n### 개념 2: LED의 극성\n\n1. **비유로 시작**: \"LED는 마치 **일방통행 도로**와 같아요. 전류가 정해진 방향으로만 흐를 수 있습니다.\"\n\n2. **정확한 정의**: \"LED(Light Emitting Diode)는 전류 방향이 정해진 부품입니다. 긴 다리가 양극(+, 애노드), 짧은 다리가 음극(-, 캐소드)입니다.\"\n\n3. **예시로 확인**: \"LED를 거꾸로 연결하면? 도로를 역주행하는 것처럼 전류가 흐르지 않아서 빛이 나지 않아요!\"\n\n```mermaid\nflowchart LR\n    subgraph LED[\"💡 LED 구분법\"]\n        direction TB\n        L1[\"긴 다리 = + (애노드)\"]\n        L2[\"짧은 다리 = - (캐소드)\"]\n        L3[\"💡 몸체 평평한 쪽 = -\"]\n    end\n    \n    A[\"🔋 전원 +\"] -->|\"긴 다리로\"| B[\"💡 LED\"]\n    B -->|\"짧은 다리에서\"| C[\"🔌 GND -\"]\n    \n    style LED fill:#fff9c4,stroke:#f9a825\n    style A fill:#c8e6c9,stroke:#2e7d32\n    style B fill:#ffecb3,stroke:#ff8f00\n    style C fill:#ffcdd2,stroke:#c62828\n```\n\n**쉽게 말하면**: **긴 다리 = 플러스(+), 짧은 다리 = 마이너스(-)**\n\n---\n\n### 개념 3: 저항의 역할\n\n1. **비유로 시작**: \"저항은 마치 **수도꼭지**와 같아요. 물(전류)이 너무 세게 흐르면 파이프(LED)가 망가지니까, 적당히 조절해주는 거예요.\"\n\n2. **정확한 정의**: \"저항은 전류의 흐름을 제한하는 부품입니다. LED에 과전류가 흐르면 타버리기 때문에, 저항으로 전류를 제한합니다.\"\n\n3. **예시로 확인**: \"피코의 3.3V에 LED를 직접 연결하면? LED가 순간적으로 밝게 빛나다가 타버릴 수 있어요! 220Ω~330Ω 저항을 함께 연결하면 안전합니다.\"\n\n**쉽게 말하면**: **저항 = LED 보호대**, 없으면 LED가 타요! 🔥\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 브레드보드 연결 이해하기\n\n**목표**: 브레드보드의 어떤 구멍들이 연결되어 있는지 파악합니다.\n\n실제로 부품을 꽂기 전에, 연결 원리를 확실히 이해해봅시다!\n\n```mermaid\nflowchart TB\n    subgraph BB[\"🔌 브레드보드 상세 구조\"]\n        direction LR\n        subgraph LEFT[\"왼쪽 전원\"]\n            LP[\"+<br>-\"]\n        end\n        subgraph CENTER[\"중앙 영역\"]\n            direction TB\n            TOP[\"1: a b c d e\"]\n            MID[\"홈 (분리선)\"]\n            BOT[\"1: f g h i j\"]\n        end\n        subgraph RIGHT[\"오른쪽 전원\"]\n            RP[\"+<br>-\"]\n        end\n    end\n    \n    style BB fill:#fafafa,stroke:#616161\n    style LEFT fill:#ffcdd2,stroke:#c62828\n    style CENTER fill:#e3f2fd,stroke:#1976d2\n    style RIGHT fill:#ffcdd2,stroke:#c62828\n```\n\n**핵심 규칙**:\n| 영역 | 연결 방향 | 용도 |\n|------|----------|------|\n| 전원 레일 (+/-) | **세로**로 전체 연결 | 전원 공급 |\n| 중앙 영역 | **가로**로 5칸씩 연결 | 부품 연결 |\n| 중앙 홈 | 위아래 **분리** | IC칩 장착용 |\n\n**여기서 잠깐! 🤔**\n> 같은 가로줄에 꽂으면 연결되고, 홈을 넘어가면 분리됩니다!\n\n---\n\n### Step 2: LED 회로 구성하기\n\n**목표**: 브레드보드에 LED와 저항을 연결합니다.\n\n**준비물**: 브레드보드, LED 1개, 220Ω 저항 1개, 점퍼선 2개\n\n```mermaid\nflowchart LR\n    subgraph PICO[\"🎛️ 피코\"]\n        GP16[\"GP16\"]\n        GND[\"GND\"]\n    end\n    \n    subgraph BREAD[\"🔌 브레드보드\"]\n        R[\"저항 220Ω\"]\n        LED[\"💡 LED\"]\n    end\n    \n    GP16 -->|\"빨간선\"| R\n    R -->|\"같은 줄\"| LED\n    LED -->|\"검은선\"| GND\n    \n    style PICO fill:#e8f5e9,stroke:#2e7d32\n    style BREAD fill:#fff3e0,stroke:#ef6c00\n```\n\n**연결 순서**:\n\n1. **저항 연결**: 저항의 한쪽 다리를 5번 줄 a에, 다른 쪽을 5번 줄 e에 꽂습니다\n2. **LED 연결**: LED의 **긴 다리(+)**를 5번 줄 d에, **짧은 다리(-)**를 10번 줄 d에 꽂습니다\n3. **점퍼선 연결**: \n   - 빨간선: 피코 GP16 → 브레드보드 5번 줄 a\n   - 검은선: 피코 GND → 브레드보드 10번 줄 a\n\n**여기서 잠깐! 🤔**\n> 저항과 LED의 긴 다리가 **같은 가로줄**에 있어야 연결됩니다!\n\n---\n\n### Step 3: 코드로 LED 제어하기\n\n**목표**: 외부 LED를 깜빡이게 합니다.\n\n**코드**:\n```python\n# === WHAT: 외부 LED를 깜빡이는 코드 ===\n# 브레드보드에 연결한 LED를 제어합니다\n\n# --- WHY: 왜 필요한지 ---\n# 내장 LED 말고, 원하는 위치에 LED를 추가하려면\n# 외부 LED 연결 방법을 알아야 해요!\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin  # 핀 제어 기능 가져오기\nimport time              # 시간 관련 기능 가져오기\n\n# GP16 핀을 출력 모드로 설정\nled = Pin(16, Pin.OUT)\n\n# 무한 반복\nwhile True:\n    led.on()         # LED 켜기 (3.3V 출력)\n    print(\"💡 LED ON\")\n    time.sleep(0.5)  # 0.5초 대기\n    \n    led.off()        # LED 끄기 (0V 출력)\n    print(\"LED OFF\")\n    time.sleep(0.5)  # 0.5초 대기\n```\n\n**실행 결과**:\n```\n💡 LED ON\nLED OFF\n💡 LED ON\nLED OFF\n...\n```\n\n**여기서 잠깐! 🤔**\n> `Pin(\"LED\")`는 내장 LED, `Pin(16)`은 GP16 핀입니다. 숫자로 쓰면 외부 핀!\n\n---\n\n### Step 4: Grove LED 사용하기 (더 쉬운 방법!)\n\n**목표**: Grove 케이블로 간편하게 LED를 연결합니다.\n\nGrove Shield가 있다면, 브레드보드 없이도 LED를 연결할 수 있어요!\n\n```mermaid\nflowchart LR\n    subgraph GS[\"🛡️ Grove Shield\"]\n        D16[\"D16 포트\"]\n    end\n    \n    subgraph GL[\"💡 Grove LED\"]\n        CONN[\"Grove 커넥터\"]\n    end\n    \n    D16 <-->|\"Grove 케이블\"| CONN\n    \n    style GS fill:#e8f5e9,stroke:#388e3c\n    style GL fill:#fff9c4,stroke:#f9a825\n```\n\n**연결 방법**: Grove LED 모듈을 Grove Shield의 **D16 포트**에 케이블로 연결하면 끝!\n\n**코드는 동일합니다**:\n```python\nfrom machine import Pin\nimport time\n\nled = Pin(16, Pin.OUT)  # D16 포트 = GP16\n\nwhile True:\n    led.toggle()     # 현재 상태 반전 (켜짐↔꺼짐)\n    time.sleep(0.5)\n```\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 외부 LED 깜빡이기 - 완성 코드 ===\n# 브레드보드 또는 Grove LED 모두 사용 가능\n\nfrom machine import Pin\nimport time\n\n# 설정\nLED_PIN = 16        # GP16 (Grove D16 포트)\nBLINK_TIME = 0.5    # 깜빡임 간격 (초)\n\n# LED 핀 설정\nled = Pin(LED_PIN, Pin.OUT)\n\nprint(\"🚀 LED 깜빡이기 시작!\")\nprint(\"중지하려면 Ctrl+C를 누르세요\")\n\n# 메인 루프\ncount = 0\nwhile True:\n    led.toggle()\n    count += 1\n    \n    if led.value():  # LED가 켜져 있으면\n        print(f\"💡 ON  (#{count})\")\n    else:\n        print(f\"   OFF (#{count})\")\n    \n    time.sleep(BLINK_TIME)\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: LED가 안 켜져요!\n\n**증상**: 코드는 실행되는데 LED가 켜지지 않음\n\n**원인**: LED 방향이 거꾸로 되어 있음\n\n**해결**:\n```python\n# LED 방향 확인하기\n# 긴 다리(+) → 저항 쪽 (GP16)\n# 짧은 다리(-) → GND 쪽\n\n# 💡 팁: LED를 180도 돌려서 다시 꽂아보세요!\n```\n\n---\n\n### 실수 2: LED가 매우 어둡거나 안 켜져요\n\n**증상**: LED가 희미하게 켜지거나 전혀 안 켜짐\n\n**원인**: 같은 줄에 연결하지 않아서 회로가 끊어짐\n\n**해결**:\n```python\n# 잘못된 연결 (서로 다른 줄)\n# 저항: 5번 줄\n# LED 긴 다리: 6번 줄  ← 연결 안 됨!\n\n# 올바른 연결 (같은 줄)\n# 저항: 5번 줄 a, e\n# LED 긴 다리: 5번 줄 d  ← 연결됨!\n```\n\n---\n\n### 실수 3: 저항 없이 연결했어요\n\n**증상**: LED가 엄청 밝았다가 갑자기 안 켜짐\n\n**원인**: 과전류로 LED가 손상됨\n\n**해결**:\n```python\n# 잘못된 회로: GP16 → LED → GND (저항 없음)\n# 위험! LED가 타버릴 수 있어요 🔥\n\n# 올바른 회로: GP16 → 저항 → LED → GND\n# 220Ω ~ 330Ω 저항을 반드시 연결하세요!\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **브레드보드에서 같은 가로줄의 a, b, c, d, e 구멍은 서로 연결되어 있나요, 분리되어 있나요?**\n\n2. **LED의 긴 다리는 +극인가요, -극인가요?**\n\n3. **저항을 연결하지 않으면 어떤 문제가 생길 수 있나요?**\n\n<details>\n<summary>정답 확인</summary>\n\n1. **연결되어 있습니다.** 같은 가로줄의 a-e는 내부적으로 연결되어 있어요.\n\n2. **+극(양극, 애노드)입니다.** 긴 다리 = +, 짧은 다리 = - 로 기억하세요!\n\n3. **LED가 과전류로 손상될 수 있습니다.** 저항은 전류를 제한해서 LED를 보호하는 역할을 합니다.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 깜빡임 속도 조절하기\n`BLINK_TIME` 값을 0.1, 0.2, 1.0 등으로 바꿔보세요. 어떤 변화가 있나요?\n\n### 도전 2: LED 2개 연결하기\nGP16과 GP17에 각각 LED를 연결하고, 번갈아 깜빡이게 해보세요!\n\n```python\n# 힌트\nled1 = Pin(16, Pin.OUT)\nled2 = Pin(17, Pin.OUT)\n# 번갈아 켜려면?\n```\n\n### 도전 3: SOS 신호 만들기 ⭐\n모스 부호로 SOS(···−−−···)를 LED로 표현해보세요!\n- 점(·): 0.2초 켜기\n- 선(−): 0.6초 켜기\n- 글자 사이: 0.4초 끄기\n\n---\n\n## 🔗 다음 장으로\n\n이번 장에서 배운 것:\n- ✅ 브레드보드의 연결 구조 (가로 연결, 홈으로 분리)\n- ✅ LED의 극성 (+긴 다리, -짧은 다리)\n- ✅ 저항으로 LED 보호하기\n- ✅ 외부 LED를 코드로 제어하기\n\n**다음 장**에서는 **PWM으로 LED 밝기 조절하기**를 배웁니다. 단순히 켜고 끄는 것을 넘어서, LED를 서서히 밝아지게 하거나 어둡게 하는 방법을 알아볼 거예요! 🌟",
      "tokens_used": 18721,
      "input_tokens": 13349,
      "output_tokens": 5372
    },
    {
      "success": true,
      "chapter_id": "chapter05",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter05.md",
      "content": "# 깜빡깜빡 - LED 점멸 프로그램\n\n**Part 2**: 빛으로 말하기 - LED 제어\n\n---\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] GPIO 핀의 개념과 출력 모드를 설명할 수 있다\n- [ ] `while` 반복문으로 무한히 반복하는 코드를 작성할 수 있다\n- [ ] `sleep()` 함수로 시간 간격을 조절할 수 있다\n- [ ] LED를 원하는 속도로 깜빡이게 만들 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n앞 장에서 LED를 켜고 껐죠? 하지만 한 번 켜고 끝나면 심심하잖아요! 🙄\n\n실제 세상의 LED를 떠올려 보세요:\n- 🚗 자동차 방향지시등: 깜빡깜빡\n- 🚨 비상구 표시등: 깜빡깜빡\n- 🎄 크리스마스 트리 조명: 반짝반짝\n\n모두 **반복적으로** 켜졌다 꺼졌다 하죠! 이번 장에서는 컴퓨터에게 \"이걸 계속 반복해!\"라고 명령하는 방법을 배웁니다. 이게 바로 **반복문**이에요.\n\n반복문을 익히면 LED뿐 아니라 \"센서 값을 계속 읽기\", \"계속 대기하며 버튼 누름 확인하기\" 같은 모든 피지컬 컴퓨팅의 기본이 됩니다!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: GPIO 출력 모드\n\n1. **비유로 시작**: GPIO 핀은 마치 **전기 스위치**와 같아요. 스위치를 켜면(HIGH) 전기가 흐르고, 끄면(LOW) 전기가 멈추죠.\n\n2. **정확한 정의**: GPIO(General Purpose Input/Output)는 범용 입출력 핀입니다. **출력 모드**로 설정하면 핀에서 전기 신호(3.3V 또는 0V)를 내보낼 수 있습니다.\n\n3. **예시로 확인**: LED를 GP16 핀에 연결하고 출력 모드로 설정하면, 코드로 \"켜!\" 또는 \"꺼!\"를 명령할 수 있어요.\n\n**쉽게 말하면**: 피코의 핀을 \"전기를 내보내는 모드\"로 설정하는 거예요.\n\n---\n\n### 개념 2: 반복문 (while)\n\n1. **비유로 시작**: 반복문은 마치 **노래 반복 재생** 버튼과 같아요. 한 번 누르면 노래가 끝나도 계속 처음부터 다시 재생되죠.\n\n2. **정확한 정의**: `while True:`는 조건이 참(True)인 동안 코드 블록을 **무한히 반복** 실행합니다.\n\n3. **예시로 확인**:\n```python\nwhile True:\n    print(\"안녕!\")  # 이 줄이 무한히 반복됨\n```\n\n**쉽게 말하면**: \"이 코드를 영원히 반복해!\"라고 명령하는 거예요.\n\n---\n\n### 개념 3: sleep() 함수\n\n1. **비유로 시작**: sleep()은 마치 **알람 없는 낮잠**과 같아요. 정해진 시간 동안 아무것도 하지 않고 기다립니다.\n\n2. **정확한 정의**: `time.sleep(초)`는 프로그램을 지정한 초(seconds) 동안 **일시 정지**시킵니다.\n\n3. **예시로 확인**:\n```python\ntime.sleep(1)    # 1초 대기\ntime.sleep(0.5)  # 0.5초(500ms) 대기\n```\n\n**쉽게 말하면**: \"잠깐 멈춰!\"를 몇 초간 할지 정하는 거예요.\n\n---\n\n### 💡 개념 연결: LED 점멸의 원리\n\n```mermaid\nflowchart LR\n    A[💡 LED 켜기] --> B[⏱️ 잠시 대기]\n    B --> C[🌑 LED 끄기]\n    C --> D[⏱️ 잠시 대기]\n    D --> A\n    \n    style A fill:#fff9c4,stroke:#f9a825\n    style B fill:#e3f2fd,stroke:#1976d2\n    style C fill:#eceff1,stroke:#546e7a\n    style D fill:#e3f2fd,stroke:#1976d2\n```\n\n이 네 단계가 **무한히 반복**되면 LED가 깜빡이는 것처럼 보여요!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: LED 한 번 깜빡이기\n\n**목표**: LED를 켜고, 1초 기다리고, 끄는 기본 동작 확인하기\n\n**코드**:\n```python\n# === WHAT: LED를 한 번 깜빡이는 코드 ===\n# LED를 켰다가 1초 후에 끕니다\n\n# --- WHY: 왜 필요한지 ---\n# 반복하기 전에 기본 동작이 되는지 먼저 확인해야 해요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin  # 핀 제어 도구 가져오기\nimport time              # 시간 관련 도구 가져오기\n\nled = Pin(16, Pin.OUT)   # GP16 핀을 출력 모드로 설정\n\nled.value(1)             # LED 켜기 (HIGH, 3.3V 출력)\ntime.sleep(1)            # 1초 동안 대기\nled.value(0)             # LED 끄기 (LOW, 0V 출력)\n```\n\n**실행 결과**:\n```\n(LED가 1초간 켜졌다가 꺼집니다)\n```\n\n**여기서 잠깐! 🤔**\n- `value(1)` = HIGH = 켜기, `value(0)` = LOW = 끄기\n- 숫자 16은 Grove Shield의 D16 포트에 해당해요\n\n---\n\n### Step 2: 무한 반복으로 계속 깜빡이기\n\n**목표**: `while True:`로 LED가 계속 깜빡이게 만들기\n\n**코드**:\n```python\n# === WHAT: LED를 계속 깜빡이는 코드 ===\n# LED가 1초마다 켜졌다 꺼졌다를 무한 반복합니다\n\n# --- WHY: 왜 필요한지 ---\n# 한 번만 깜빡이면 프로그램이 끝나버려요\n# 계속 깜빡이려면 반복문이 필요해요!\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin\nimport time\n\nled = Pin(16, Pin.OUT)\n\nwhile True:              # 아래 코드를 무한 반복!\n    led.value(1)         # LED 켜기\n    time.sleep(1)        # 1초 대기\n    led.value(0)         # LED 끄기\n    time.sleep(1)        # 1초 대기 (이게 없으면?)\n```\n\n**실행 결과**:\n```\n(LED가 1초 켜짐 → 1초 꺼짐 → 반복...)\n```\n\n**여기서 잠깐! 🤔**\n마지막 `sleep(1)`이 없으면 어떻게 될까요? LED가 꺼지자마자 바로 다시 켜져서 **거의 꺼진 것처럼 안 보여요**! 끄고 나서도 잠깐 기다려야 \"깜빡임\"이 눈에 보입니다.\n\n---\n\n### Step 3: 깜빡이는 속도 조절하기\n\n**목표**: sleep 시간을 바꿔서 빠르게/느리게 깜빡이기\n\n**코드**:\n```python\n# === WHAT: 빠르게 깜빡이는 LED ===\n# 비상등처럼 빠르게 깜빡입니다\n\n# --- WHY: 왜 필요한지 ---\n# 상황에 따라 깜빡이는 속도가 달라야 해요\n# 비상등은 빠르게, 호흡등은 느리게!\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin\nimport time\n\nled = Pin(16, Pin.OUT)\n\n# 깜빡임 간격을 변수로 만들면 수정이 쉬워요!\ninterval = 0.2           # 0.2초 = 200ms (빠른 깜빡임)\n\nwhile True:\n    led.value(1)\n    time.sleep(interval)  # 변수 사용\n    led.value(0)\n    time.sleep(interval)\n```\n\n**실행 결과**:\n```\n(LED가 0.2초마다 빠르게 깜빡입니다)\n```\n\n**💡 실험해보세요!**\n| interval 값 | 느낌 |\n|------------|------|\n| 0.1 | 매우 빠름 (비상!) |\n| 0.5 | 적당히 빠름 |\n| 1.0 | 느긋함 |\n| 2.0 | 매우 느림 (졸려...) |\n\n---\n\n## 📝 전체 코드\n\n```python\n# === LED 점멸 프로그램 ===\n# 피코의 GP16에 연결된 LED를 깜빡이게 합니다\n# 실행 후 멈추려면 Thonny의 Stop 버튼을 누르세요!\n\nfrom machine import Pin\nimport time\n\n# 설정\nled = Pin(16, Pin.OUT)   # D16 포트의 LED\ninterval = 0.5           # 깜빡임 간격 (초)\n\n# 무한 반복\nwhile True:\n    led.value(1)         # 켜기\n    time.sleep(interval)\n    led.value(0)         # 끄기\n    time.sleep(interval)\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 들여쓰기 빠뜨리기\n\n**증상**: `IndentationError: expected an indented block`\n\n**원인**: `while True:` 다음 줄은 반드시 들여쓰기(스페이스 4칸)가 필요해요!\n\n**해결**:\n```python\n# 잘못된 코드\nwhile True:\nled.value(1)  # ❌ 들여쓰기 없음!\n\n# 올바른 코드\nwhile True:\n    led.value(1)  # ✅ 스페이스 4칸\n```\n\n---\n\n### 실수 2: 끄고 나서 sleep 안 하기\n\n**증상**: LED가 계속 켜져 있는 것처럼 보임\n\n**원인**: 끄자마자 바로 다시 켜지면 꺼진 게 안 보여요\n\n**해결**:\n```python\n# 잘못된 코드\nwhile True:\n    led.value(1)\n    time.sleep(1)\n    led.value(0)\n    # ❌ sleep 없이 바로 다시 켜짐!\n\n# 올바른 코드\nwhile True:\n    led.value(1)\n    time.sleep(1)\n    led.value(0)\n    time.sleep(1)  # ✅ 끄고 나서도 대기\n```\n\n---\n\n### 실수 3: 프로그램 멈추는 방법 모르기\n\n**증상**: LED가 계속 깜빡여서 새 코드를 실행 못함\n\n**원인**: `while True:`는 무한 반복이라 스스로 안 멈춰요!\n\n**해결**:\n- Thonny 상단의 **🔴 Stop** 버튼 클릭\n- 또는 **Ctrl + C** 키 누르기\n\n---\n\n## ✅ 스스로 점검하기\n\n1. `Pin(16, Pin.OUT)`에서 `Pin.OUT`의 의미는 무엇인가요?\n\n2. `while True:`를 사용하지 않고 LED를 5번만 깜빡이게 하려면 어떻게 해야 할까요?\n\n3. 왜 LED를 끄고 나서도 `sleep()`이 필요한가요?\n\n<details>\n<summary>정답 확인</summary>\n\n1. **Pin.OUT**: 해당 핀을 **출력 모드**로 설정한다는 의미예요. 핀에서 전기 신호를 내보낼 수 있게 됩니다.\n\n2. `for` 반복문을 사용하면 됩니다:\n```python\nfor i in range(5):  # 5번 반복\n    led.value(1)\n    time.sleep(0.5)\n    led.value(0)\n    time.sleep(0.5)\n```\n\n3. 끄자마자 바로 다시 켜지면, 꺼진 시간이 너무 짧아서 **사람 눈에는 계속 켜져 있는 것처럼** 보여요. 깜빡임을 보려면 끄고 나서도 기다려야 합니다.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: SOS 신호 만들기 🆘\n모스 부호 SOS는 `· · · — — — · · ·` (짧게 3번, 길게 3번, 짧게 3번)입니다.\n- 짧은 신호: 0.2초\n- 긴 신호: 0.6초\n- 신호 사이: 0.2초 대기\n\n### 도전 2: 심장 박동 LED 💓\n심장처럼 \"쿵... 쿵쿵... 쿵... 쿵쿵...\" 리듬으로 깜빡이게 만들어보세요!\n- 첫 번째 박동: 짧게\n- 두 번째 박동: 빠르게 두 번\n- 그리고 잠시 쉬기\n\n### 도전 3: 점점 빨라지는 LED ⭐\n시작은 1초 간격으로 깜빡이다가, 점점 빨라져서 0.1초 간격까지 빨라지게 만들어보세요! (힌트: 변수를 반복문 안에서 줄이기)\n\n---\n\n## 🔗 다음 장으로\n\n축하해요! 🎉 이제 여러분은:\n- GPIO 핀으로 전기 신호를 **출력**하는 방법\n- `while True:`로 코드를 **무한 반복**하는 방법\n- `sleep()`으로 **시간 조절**하는 방법\n\n을 알게 되었어요!\n\n**다음 장 \"밝기 조절 - PWM으로 LED 페이드\"** 에서는 LED를 그냥 켜고 끄는 것을 넘어서, **서서히 밝아지고 어두워지게** 만드는 방법을 배웁니다. 마치 고급 무드등처럼요! ✨",
      "tokens_used": 17968,
      "input_tokens": 13384,
      "output_tokens": 4584
    },
    {
      "success": true,
      "chapter_id": "chapter06",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter06.md",
      "content": "# 🌈 6장. 무지개 신호등 - 다중 LED 패턴\n\n> **Part 2**: 빛으로 말하기 - LED 제어\n\n---\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 여러 개의 LED를 동시에 제어할 수 있다\n- [ ] 리스트를 활용해 LED들을 효율적으로 관리할 수 있다\n- [ ] 신호등 패턴을 프로그래밍할 수 있다\n- [ ] for 반복문으로 LED 순차 점등을 구현할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n지금까지 LED 하나를 껐다 켰다 해봤죠? 근데 실제 세상을 보세요. 신호등은 빨강-노랑-초록 **3개**가 순서대로 켜지고, 크리스마스 트리 조명은 **수십 개**가 물결처럼 움직여요.\n\nLED 10개를 제어하려면 코드 10줄을 일일이 써야 할까요? **아니요!** 오늘 배울 **리스트**를 사용하면 LED가 100개여도 단 몇 줄로 끝납니다.\n\n이건 실제로 많이 쓰여요:\n- 🚦 교차로 신호등 시스템\n- 🎄 LED 스트립 조명\n- 🚗 자동차 후미등 순차 점멸\n- 🎮 게임 컨트롤러 상태 표시\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 리스트(List)\n\n1. **비유로 시작**: \"리스트는 마치 **기차 칸**과 같아요. 여러 개의 물건을 순서대로 한 줄로 연결해서 보관하는 거죠.\"\n\n2. **정확한 정의**: \"정확히 말하면, 리스트는 **여러 데이터를 순서대로 담는 파이썬 자료구조**입니다. 대괄호 `[]`로 만들고, 각 항목은 번호(인덱스)로 접근해요.\"\n\n3. **예시로 확인**:\n```python\n# LED가 연결된 핀 번호들을 리스트로!\nled_pins = [16, 17, 18]  # 빨강, 노랑, 초록\n\n# 첫 번째 핀 번호 가져오기 (인덱스는 0부터!)\nprint(led_pins[0])  # 16 출력\nprint(led_pins[1])  # 17 출력\nprint(led_pins[2])  # 18 출력\n```\n\n**쉽게 말하면**: 여러 개를 한 묶음으로 관리하는 마법 상자!\n\n```mermaid\nflowchart LR\n    subgraph 리스트[\"📦 led_pins 리스트\"]\n        A[\"[0] 16<br/>빨강\"]\n        B[\"[1] 17<br/>노랑\"]\n        C[\"[2] 18<br/>초록\"]\n    end\n    A --> B --> C\n    style A fill:#ffcdd2,stroke:#c62828\n    style B fill:#fff9c4,stroke:#f9a825\n    style C fill:#c8e6c9,stroke:#2e7d32\n```\n\n---\n\n### 개념 2: for 반복문\n\n1. **비유로 시작**: \"for문은 **자동 반복 기계**예요. 리스트에 있는 것들을 하나씩 꺼내서 같은 작업을 반복해줍니다.\"\n\n2. **정확한 정의**: \"for문은 **반복 가능한 객체의 각 요소에 대해 코드 블록을 실행**하는 제어문입니다.\"\n\n3. **예시로 확인**:\n```python\ncolors = [\"빨강\", \"노랑\", \"초록\"]\n\nfor color in colors:\n    print(f\"{color} LED 켜기!\")\n    \n# 출력:\n# 빨강 LED 켜기!\n# 노랑 LED 켜기!\n# 초록 LED 켜기!\n```\n\n**쉽게 말하면**: \"이 목록에 있는 거 **하나씩** 전부 처리해!\"\n\n```mermaid\nflowchart TD\n    A[🚀 시작] --> B[📦 리스트에서<br/>하나 꺼내기]\n    B --> C{남은 게<br/>있나요?}\n    C -->|예| D[⚡ 작업 실행]\n    D --> B\n    C -->|아니오| E[🏁 끝]\n    style A fill:#e3f2fd,stroke:#1976d2\n    style C fill:#fff3e0,stroke:#f57c00\n    style D fill:#e8f5e9,stroke:#388e3c\n    style E fill:#f3e5f5,stroke:#7b1fa2\n```\n\n---\n\n## 🔨 따라하기\n\n### 준비물\n| 부품 | 수량 | 연결 |\n|------|------|------|\n| Grove LED (빨강) | 1 | D16 포트 |\n| Grove LED (노랑/주황) | 1 | D17 포트 |\n| Grove LED (초록) | 1 | D18 포트 |\n| Grove 케이블 | 3 | - |\n\n---\n\n### Step 1: 3개 LED 연결하고 개별 테스트\n\n**목표**: 각 LED가 제대로 연결됐는지 확인하기\n\n**코드**:\n```python\n# === WHAT: 3개 LED 개별 점등 테스트 ===\n# 신호등처럼 빨강, 노랑, 초록 LED를 하나씩 켜본다\n\n# --- WHY: 왜 필요한지 ---\n# 여러 LED를 제어하기 전에 각각 잘 연결됐는지 먼저 확인!\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin  # 핀 제어용\nimport time              # 시간 지연용\n\n# 각 LED를 개별 변수로 설정\nred = Pin(16, Pin.OUT)    # 빨간 LED - D16 포트\nyellow = Pin(17, Pin.OUT) # 노란 LED - D17 포트  \ngreen = Pin(18, Pin.OUT)  # 초록 LED - D18 포트\n\n# 하나씩 테스트\nprint(\"빨간 LED 테스트\")\nred.on()\ntime.sleep(1)\nred.off()\n\nprint(\"노란 LED 테스트\")\nyellow.on()\ntime.sleep(1)\nyellow.off()\n\nprint(\"초록 LED 테스트\")\ngreen.on()\ntime.sleep(1)\ngreen.off()\n\nprint(\"테스트 완료!\")\n```\n\n**실행 결과**:\n```\n빨간 LED 테스트\n노란 LED 테스트\n초록 LED 테스트\n테스트 완료!\n```\n(각 LED가 1초씩 순서대로 켜졌다 꺼짐)\n\n**여기서 잠깐! 🤔**\n코드가 비슷한 게 3번 반복되죠? 이걸 더 짧게 줄일 수 있어요!\n\n---\n\n### Step 2: 리스트로 LED 관리하기\n\n**목표**: 3개 LED를 리스트 하나로 묶어서 관리\n\n**코드**:\n```python\n# === WHAT: 리스트로 LED 관리 ===\n# 여러 LED를 하나의 리스트로 묶어 효율적으로 제어\n\n# --- WHY: 왜 필요한지 ---\n# LED 10개면 변수 10개? NO! 리스트 하나면 충분!\n\nfrom machine import Pin\nimport time\n\n# 핀 번호를 리스트로\npin_numbers = [16, 17, 18]\n\n# LED 객체들도 리스트로!\nleds = []  # 빈 리스트 만들기\n\nfor pin_num in pin_numbers:\n    led = Pin(pin_num, Pin.OUT)  # LED 객체 생성\n    leds.append(led)             # 리스트에 추가\n    \nprint(f\"LED {len(leds)}개 준비 완료!\")\n\n# for문으로 모든 LED 순차 점등\nfor i, led in enumerate(leds):\n    print(f\"LED {i+1} 켜기\")\n    led.on()\n    time.sleep(0.5)\n    led.off()\n    \nprint(\"완료!\")\n```\n\n**실행 결과**:\n```\nLED 3개 준비 완료!\nLED 1 켜기\nLED 2 켜기\nLED 3 켜기\n완료!\n```\n\n**여기서 잠깐! 🤔**\n- `leds.append(led)`: 리스트 끝에 새 항목 추가\n- `enumerate(leds)`: 순서 번호(i)와 값(led)을 함께 가져옴\n- LED가 100개여도 `pin_numbers`만 늘리면 끝!\n\n---\n\n### Step 3: 진짜 신호등 만들기!\n\n**목표**: 실제 교통 신호등처럼 동작하는 프로그램\n\n**코드**:\n```python\n# === WHAT: 교통 신호등 시뮬레이션 ===\n# 빨강(정지) → 초록(통행) → 노랑(주의) 순서로 반복\n\n# --- WHY: 왜 필요한지 ---\n# 실제 신호등 타이밍을 이해하고 구현해보자!\n\nfrom machine import Pin\nimport time\n\n# LED 설정 (빨강, 노랑, 초록 순서)\nred = Pin(16, Pin.OUT)\nyellow = Pin(17, Pin.OUT)\ngreen = Pin(18, Pin.OUT)\n\ndef all_off():\n    \"\"\"모든 LED 끄기\"\"\"\n    red.off()\n    yellow.off()\n    green.off()\n\ndef traffic_light():\n    \"\"\"신호등 한 사이클 실행\"\"\"\n    # 1. 빨간불 - 정지 (3초)\n    all_off()\n    red.on()\n    print(\"🔴 빨간불 - 정지!\")\n    time.sleep(3)\n    \n    # 2. 초록불 - 통행 (3초)\n    all_off()\n    green.on()\n    print(\"🟢 초록불 - 통행!\")\n    time.sleep(3)\n    \n    # 3. 노란불 - 주의 (1초)\n    all_off()\n    yellow.on()\n    print(\"🟡 노란불 - 주의!\")\n    time.sleep(1)\n\n# 메인 루프: 3번 반복\nprint(\"=== 신호등 시작 ===\")\nfor cycle in range(3):\n    print(f\"\\n--- {cycle + 1}번째 사이클 ---\")\n    traffic_light()\n\nall_off()\nprint(\"\\n=== 신호등 종료 ===\")\n```\n\n**실행 결과**:\n```\n=== 신호등 시작 ===\n\n--- 1번째 사이클 ---\n🔴 빨간불 - 정지!\n🟢 초록불 - 통행!\n🟡 노란불 - 주의!\n\n--- 2번째 사이클 ---\n...\n```\n\n---\n\n### Step 4: 기사단 LED (Knight Rider) 효과\n\n**목표**: LED가 좌→우→좌로 왔다갔다 하는 멋진 효과!\n\n**코드**:\n```python\n# === WHAT: 기사단 LED 효과 ===\n# 80년대 드라마 '전격 Z작전'의 KITT 자동차처럼!\n\nfrom machine import Pin\nimport time\n\n# LED 리스트 (왼쪽부터 오른쪽 순서)\npin_numbers = [16, 17, 18]\nleds = [Pin(p, Pin.OUT) for p in pin_numbers]  # 한 줄로 생성!\n\ndef all_off():\n    for led in leds:\n        led.off()\n\ndef knight_rider(speed=0.15):\n    \"\"\"기사단 효과: 좌→우→좌 한 사이클\"\"\"\n    # 왼쪽 → 오른쪽\n    for led in leds:\n        all_off()\n        led.on()\n        time.sleep(speed)\n    \n    # 오른쪽 → 왼쪽 (역순, 양 끝 제외)\n    for led in reversed(leds[1:-1]):\n        all_off()\n        led.on()\n        time.sleep(speed)\n\n# 5번 반복\nprint(\"🚗 Knight Rider 시작!\")\nfor _ in range(5):\n    knight_rider(0.1)  # 속도 조절 가능\n\nall_off()\nprint(\"완료!\")\n```\n\n**여기서 잠깐! 🤔**\n- `[Pin(p, Pin.OUT) for p in pin_numbers]`: 리스트 컴프리헨션! 한 줄로 리스트 생성\n- `reversed()`: 리스트를 거꾸로 순회\n- `leds[1:-1]`: 첫 번째와 마지막 제외 (중복 방지)\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 다중 LED 패턴 종합 ===\n# 신호등 + 기사단 효과를 버튼으로 전환!\n\nfrom machine import Pin\nimport time\n\n# === 하드웨어 설정 ===\npin_numbers = [16, 17, 18]\nleds = [Pin(p, Pin.OUT) for p in pin_numbers]\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)  # 버튼 (있다면)\n\n# === 유틸리티 함수 ===\ndef all_off():\n    \"\"\"모든 LED 끄기\"\"\"\n    for led in leds:\n        led.off()\n\ndef all_on():\n    \"\"\"모든 LED 켜기\"\"\"\n    for led in leds:\n        led.on()\n\n# === 패턴 함수들 ===\ndef pattern_blink(times=3, speed=0.3):\n    \"\"\"전체 깜빡이기\"\"\"\n    for _ in range(times):\n        all_on()\n        time.sleep(speed)\n        all_off()\n        time.sleep(speed)\n\ndef pattern_wave(times=3, speed=0.15):\n    \"\"\"파도처럼 순차 점등\"\"\"\n    for _ in range(times):\n        for led in leds:\n            led.on()\n            time.sleep(speed)\n        for led in leds:\n            led.off()\n            time.sleep(speed)\n\ndef pattern_knight(times=3, speed=0.1):\n    \"\"\"기사단 효과\"\"\"\n    for _ in range(times):\n        for led in leds:\n            all_off()\n            led.on()\n            time.sleep(speed)\n        for led in reversed(leds[1:-1]):\n            all_off()\n            led.on()\n            time.sleep(speed)\n    all_off()\n\n# === 메인 실행 ===\nprint(\"🌈 LED 패턴 쇼 시작!\")\n\nprint(\"\\n1️⃣ 전체 깜빡이기\")\npattern_blink()\n\nprint(\"\\n2️⃣ 파도 효과\")\npattern_wave()\n\nprint(\"\\n3️⃣ 기사단 효과\")\npattern_knight()\n\nall_off()\nprint(\"\\n✨ 쇼 종료!\")\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 인덱스 범위 초과\n**증상**: `IndexError: list index out of range`\n\n**원인**: 리스트 인덱스는 **0부터** 시작! 3개짜리 리스트의 마지막은 `[2]`\n\n**해결**:\n```python\n# 잘못된 코드\nleds = [led1, led2, led3]\nprint(leds[3])  # ❌ 에러! 0, 1, 2만 있음\n\n# 올바른 코드\nprint(leds[2])  # ✅ 마지막 요소\nprint(leds[-1]) # ✅ 음수는 뒤에서부터!\n```\n\n---\n\n### 실수 2: LED가 안 꺼지고 계속 켜져 있음\n**증상**: 다음 LED 켜도 이전 LED가 안 꺼짐\n\n**원인**: `all_off()` 호출을 빼먹음\n\n**해결**:\n```python\n# 잘못된 코드\nfor led in leds:\n    led.on()      # 켜기만 하고 안 끔!\n    time.sleep(0.5)\n\n# 올바른 코드\nfor led in leds:\n    all_off()     # 먼저 전부 끄고\n    led.on()      # 하나만 켜기\n    time.sleep(0.5)\n```\n\n---\n\n### 실수 3: 핀 번호와 포트 번호 혼동\n**증상**: LED가 아예 안 켜지거나 엉뚱한 게 켜짐\n\n**원인**: Grove 포트 번호(D16)와 GPIO 핀 번호(16)를 혼동\n\n**해결**:\n```python\n# Grove Shield 포트별 GPIO 핀 번호\n# D16 포트 → GPIO 16\n# D17 포트 → GPIO 17  (일부 쉴드는 다를 수 있음)\n# D18 포트 → GPIO 18\n\n# 쉴드 실크스크린 확인하세요!\nled = Pin(16, Pin.OUT)  # D16 포트에 연결했다면\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **리스트 `[10, 20, 30]`에서 20을 가져오려면 어떻게 쓰나요?**\n\n2. **for문으로 리스트의 모든 요소를 출력하는 코드를 작성해보세요.**\n\n3. **신호등에서 노란불이 가장 짧은 이유는 뭘까요?**\n\n<details>\n<summary>정답 확인</summary>\n\n1. `리스트[1]` - 인덱스는 0부터 시작하므로 두 번째 요소는 1번!\n\n2. ```python\n   my_list = [10, 20, 30]\n   for item in my_list:\n       print(item)\n   ```\n\n3. 노란불은 \"곧 빨간불로 바뀐다\"는 경고 신호예요. 너무 길면 운전자가 무시하고 지나가려 할 수 있어서, 보통 3~5초로 짧게 설정합니다!\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 속도 조절 (쉬움)\n기사단 효과의 속도를 0.05초로 바꿔서 더 빠르게 만들어보세요!\n\n### 도전 2: 랜덤 패턴 (중간)\n```python\nimport random\n# random.choice(leds)를 사용해서 \n# 랜덤한 LED가 켜지게 만들어보세요!\n```\n\n### 도전 3: 보행자 신호등 (도전) ⭐\n실제 보행자 신호등처럼:\n- 초록불일 때 \"삐삐삐\" 소리 (print로 대체 가능)\n- 빨간불로 바뀌기 전 초록불 깜빡임 5회\n- 힌트: 부저(Buzzer)를 연결하면 진짜 소리도 가능!\n\n---\n\n## 🔗 다음 장으로\n\n오늘 배운 것:\n- ✅ **리스트**: 여러 데이터를 한 묶음으로!\n- ✅ **for문**: 리스트 항목 하나씩 처리\n- ✅ **패턴 구현**: 신호등, 기사단 효과\n\n다음 장에서는 **버튼**을 배워요! 버튼을 누르면 LED 패턴이 바뀌게 만들 수 있어요. 사용자의 **입력**을 받아서 반응하는 진짜 인터랙티브 장치를 만들어봅시다! 🎮",
      "tokens_used": 19266,
      "input_tokens": 13360,
      "output_tokens": 5906
    },
    {
      "success": true,
      "chapter_id": "chapter07",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter07.md",
      "content": "# Chapter 7: 버튼 연결하기 - 디지털 입력의 시작\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 푸시 버튼의 동작 원리를 이해할 수 있다\n- [ ] 풀업/풀다운 저항이 왜 필요한지 설명할 수 있다\n- [ ] 피코의 내부 풀다운 저항을 사용하여 버튼을 연결할 수 있다\n- [ ] 버튼 상태를 읽어 화면에 출력할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n지금까지 우리는 피코에게 **일방적으로 명령**만 내렸어요. \"LED 켜!\", \"LED 꺼!\" 처럼요.\n\n하지만 진짜 스마트한 기기는 **사용자의 입력을 받아** 반응해요. 스마트폰 화면을 터치하면 앱이 열리고, 리모컨 버튼을 누르면 TV 채널이 바뀌죠.\n\n**버튼**은 가장 기본적인 입력 장치예요. 버튼 하나만 제대로 이해하면, 나중에 터치 센서, 모션 감지 센서 등 모든 **디지털 입력**의 원리를 파악할 수 있어요!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 디지털 입력이란?\n\n1. **비유로 시작**: 디지털 입력은 마치 **예/아니오 질문**과 같아요. \"버튼 눌렸어?\" → \"응(1)\" 또는 \"아니(0)\"\n\n2. **정확한 정의**: 디지털 입력은 GPIO 핀으로 들어오는 전기 신호를 **HIGH(1)** 또는 **LOW(0)**로 읽는 것입니다.\n\n3. **예시로 확인**: 버튼을 누르면 → 전기가 흐름 → HIGH(1), 버튼을 떼면 → 전기가 안 흐름 → LOW(0)\n\n**쉽게 말하면**: 피코한테 \"지금 버튼 눌렸어?\"라고 물어보고 0 또는 1로 답을 받는 거예요!\n\n---\n\n### 개념 2: 풀다운 저항이 필요한 이유\n\n버튼을 연결할 때 한 가지 문제가 있어요. 버튼을 **누르지 않았을 때** 핀이 어떤 상태인지 애매해요!\n\n```mermaid\nflowchart LR\n    subgraph 문제상황[\"❓ 버튼 안 눌렀을 때\"]\n        A[GPIO 핀] --> B[\"??? <br/>HIGH? LOW?\"]\n    end\n    \n    subgraph 해결책[\"✅ 풀다운 저항 사용\"]\n        C[GPIO 핀] --> D[\"저항으로<br/>GND 연결\"]\n        D --> E[\"확실히 LOW!\"]\n    end\n    \n    style 문제상황 fill:#ffebee,stroke:#c62828\n    style 해결책 fill:#e8f5e9,stroke:#388e3c\n```\n\n1. **비유로 시작**: 풀다운 저항은 마치 **기본값 설정**과 같아요. \"아무것도 안 하면 0으로 해줘!\"\n\n2. **정확한 정의**: 풀다운 저항은 입력 핀을 GND(0V)에 연결하여, 아무 신호가 없을 때 **확실히 LOW 상태**를 유지하게 해줍니다.\n\n3. **예시로 확인**: \n   - 버튼 안 눌림 → 풀다운 저항이 핀을 GND로 당김 → LOW(0)\n   - 버튼 눌림 → 3.3V 전원이 연결됨 → HIGH(1)\n\n**쉽게 말하면**: \"버튼 안 누르면 무조건 0이야!\"라고 확실히 정해주는 장치예요.\n\n> 💡 **좋은 소식!** 피코에는 **내부 풀다운 저항**이 내장되어 있어서, 코드 한 줄로 쉽게 사용할 수 있어요!\n\n---\n\n### 개념 3: Pin.IN과 PULL_DOWN\n\n```mermaid\nflowchart TB\n    subgraph 출력모드[\"📤 Pin.OUT (출력)\"]\n        A1[\"피코가 신호를 보냄\"] --> A2[\"LED 켜기/끄기\"]\n    end\n    \n    subgraph 입력모드[\"📥 Pin.IN (입력)\"]\n        B1[\"피코가 신호를 받음\"] --> B2[\"버튼 상태 읽기\"]\n    end\n    \n    style 출력모드 fill:#fff3e0,stroke:#f57c00\n    style 입력모드 fill:#e3f2fd,stroke:#1976d2\n```\n\n| 모드 | 역할 | 사용 예 |\n|------|------|---------|\n| `Pin.OUT` | 피코가 신호를 **내보냄** | LED, 부저, 모터 |\n| `Pin.IN` | 피코가 신호를 **받아들임** | 버튼, 센서 |\n| `Pin.PULL_DOWN` | 내부 풀다운 저항 활성화 | 버튼 연결 시 필수! |\n\n**쉽게 말하면**: `Pin.OUT`은 \"말하기\", `Pin.IN`은 \"듣기\"예요!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: Grove 버튼 연결하기\n\n**목표**: Grove 버튼을 피코에 연결합니다.\n\nGrove 버튼은 연결이 정말 간단해요! 케이블 하나로 끝!\n\n```mermaid\nflowchart LR\n    subgraph 피코[\"🔌 Pico + Grove Shield\"]\n        D20[\"D20 포트\"]\n    end\n    \n    subgraph 버튼[\"🔘 Grove 버튼\"]\n        BTN[\"버튼 모듈\"]\n    end\n    \n    D20 <-->|\"Grove 케이블\"| BTN\n    \n    style 피코 fill:#e3f2fd,stroke:#1976d2\n    style 버튼 fill:#fff3e0,stroke:#f57c00\n```\n\n**연결 방법**:\n1. Grove 버튼 모듈을 준비해요\n2. Grove 케이블로 **D20 포트**에 연결해요\n3. 끝! 정말 간단하죠? 😄\n\n> ⚠️ **주의**: Grove 케이블의 방향은 상관없어요. 어느 쪽으로 꽂아도 돼요!\n\n---\n\n### Step 2: 버튼 상태 읽기\n\n**목표**: 버튼이 눌렸는지 안 눌렸는지 확인합니다.\n\n**코드**:\n```python\n# === WHAT: 버튼 상태를 읽어서 출력하는 코드 ===\n# 버튼을 누르면 1, 떼면 0이 출력돼요\n\n# --- WHY: 왜 필요한지 ---\n# 버튼이 제대로 연결됐는지 확인하고, 입력을 받는 방법을 배워요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin  # 핀 제어를 위한 라이브러리\nimport time              # 시간 관련 기능\n\n# 버튼을 D20 포트에 연결 (GP20 핀)\n# Pin.IN: 입력 모드로 설정 (신호를 받아들임)\n# Pin.PULL_DOWN: 내부 풀다운 저항 사용 (안 누르면 0)\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\n\n# 5번 반복해서 버튼 상태 확인\nfor i in range(5):\n    state = button.value()  # 버튼 상태 읽기 (0 또는 1)\n    print(f\"버튼 상태: {state}\")\n    time.sleep(1)  # 1초 대기\n```\n\n**실행 결과**:\n```\n버튼 상태: 0\n버튼 상태: 0\n버튼 상태: 1    ← 이때 버튼을 누르고 있었어요!\n버튼 상태: 1\n버튼 상태: 0\n```\n\n**여기서 잠깐! 🤔**\n\n`button.value()`는 **그 순간**의 버튼 상태만 읽어요. \n- 버튼을 누르는 순간에 읽으면 → 1\n- 버튼을 떼고 있으면 → 0\n\n---\n\n### Step 3: 실시간으로 버튼 감지하기\n\n**목표**: 버튼 상태가 바뀔 때만 메시지를 출력합니다.\n\n**코드**:\n```python\n# === WHAT: 버튼 눌림/뗌을 감지하는 코드 ===\n# 버튼 상태가 바뀔 때만 메시지가 출력돼요\n\n# --- WHY: 왜 필요한지 ---\n# 계속 같은 메시지가 출력되면 정신없어요!\n# 상태가 \"변할 때만\" 알려주는 게 더 좋아요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin\nimport time\n\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\n\n# 이전 버튼 상태를 기억하는 변수\nlast_state = 0\n\nprint(\"버튼을 눌러보세요! (Ctrl+C로 종료)\")\n\nwhile True:\n    current_state = button.value()  # 현재 버튼 상태\n    \n    # 상태가 바뀌었을 때만 출력\n    if current_state != last_state:\n        if current_state == 1:\n            print(\"🔘 버튼 눌림!\")\n        else:\n            print(\"⚪ 버튼 뗌!\")\n        \n        last_state = current_state  # 상태 업데이트\n    \n    time.sleep(0.05)  # 50ms 대기 (너무 빠른 확인 방지)\n```\n\n**실행 결과**:\n```\n버튼을 눌러보세요! (Ctrl+C로 종료)\n🔘 버튼 눌림!\n⚪ 버튼 뗌!\n🔘 버튼 눌림!\n⚪ 버튼 뗌!\n```\n\n**여기서 잠깐! 🤔**\n\n`last_state` 변수가 핵심이에요! 이전 상태를 기억해서, **바뀔 때만** 반응하게 해요.\n이런 방식을 **\"엣지 감지(Edge Detection)\"**라고 불러요.\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 버튼 상태 감지 - 완성 코드 ===\n# Grove 버튼을 D20 포트에 연결하세요\n# 버튼을 누르면 \"눌림!\", 떼면 \"뗌!\" 출력\n\nfrom machine import Pin\nimport time\n\n# 버튼 설정: GP20, 입력 모드, 내부 풀다운 저항 사용\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\n\n# 이전 상태 기억용\nlast_state = 0\npress_count = 0  # 누른 횟수 카운트\n\nprint(\"=\"*30)\nprint(\"🎮 버튼 테스트 시작!\")\nprint(\"버튼을 눌러보세요 (Ctrl+C로 종료)\")\nprint(\"=\"*30)\n\nwhile True:\n    current_state = button.value()\n    \n    if current_state != last_state:\n        if current_state == 1:\n            press_count += 1\n            print(f\"🔘 버튼 눌림! (총 {press_count}번)\")\n        else:\n            print(\"⚪ 버튼 뗌!\")\n        \n        last_state = current_state\n    \n    time.sleep(0.05)\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: PULL_DOWN을 빼먹음\n\n**증상**: 버튼을 안 눌러도 1이 나오거나, 값이 계속 바뀜\n\n**원인**: 풀다운 저항 없이 핀이 **떠 있는 상태(floating)**가 되어서 불안정해요\n\n**해결**:\n```python\n# ❌ 잘못된 코드\nbutton = Pin(20, Pin.IN)  # PULL_DOWN이 없어요!\n\n# ✅ 올바른 코드\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)  # 내부 풀다운 저항 사용\n```\n\n---\n\n### 실수 2: Pin.OUT으로 설정함\n\n**증상**: `button.value()` 값이 이상하거나 버튼이 반응 안 함\n\n**원인**: 출력 모드로 설정하면 신호를 **받는 게 아니라 보내는** 상태가 돼요\n\n**해결**:\n```python\n# ❌ 잘못된 코드\nbutton = Pin(20, Pin.OUT)  # 출력 모드네요!\n\n# ✅ 올바른 코드\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)  # 입력 모드로!\n```\n\n---\n\n### 실수 3: 포트 번호 혼동\n\n**증상**: `버튼 상태: 0`만 계속 나옴\n\n**원인**: 버튼은 D20 포트에 연결했는데, 코드에서 다른 핀 번호를 씀\n\n**해결**:\n```python\n# ❌ 잘못된 코드 (D16 포트 번호)\nbutton = Pin(16, Pin.IN, Pin.PULL_DOWN)\n\n# ✅ 올바른 코드 (D20 포트 = GP20)\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\n```\n\n> 💡 **팁**: Grove Shield의 포트 번호(D20)와 GPIO 핀 번호(GP20)의 숫자가 같아요!\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **`Pin.IN`과 `Pin.OUT`의 차이**는 무엇인가요?\n\n2. **풀다운 저항**을 사용하지 않으면 어떤 문제가 생기나요?\n\n3. 버튼을 **누르고 있을 때** `button.value()`의 값은 얼마인가요?\n\n<details>\n<summary>정답 확인</summary>\n\n1. `Pin.IN`은 **입력 모드**로 외부 신호를 읽고, `Pin.OUT`은 **출력 모드**로 신호를 내보냅니다.\n\n2. 풀다운 저항 없이는 버튼을 안 눌렀을 때 핀 상태가 **불안정(floating)**해져서, 값이 0과 1 사이를 왔다 갔다 해요.\n\n3. **1**이에요! 버튼을 누르면 3.3V가 연결되어 HIGH(1) 상태가 됩니다.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 버튼 누른 횟수 세기 (쉬움)\n버튼을 누른 횟수를 세서 \"총 5번 눌렸습니다!\" 처럼 출력해보세요.\n> 힌트: 전체 코드에 이미 `press_count` 변수가 있어요!\n\n### 도전 2: 길게 누르기 감지 (중간)\n버튼을 2초 이상 누르고 있으면 \"길게 눌렸습니다!\"라고 출력해보세요.\n> 힌트: `time.ticks_ms()`로 시간을 잴 수 있어요!\n\n### 도전 3: 더블 클릭 감지 (어려움) ⭐\n버튼을 빠르게 2번 누르면 \"더블 클릭!\"이라고 출력해보세요.\n> 힌트: 첫 번째 클릭 후 0.3초 이내에 두 번째 클릭이 오면 더블 클릭!\n\n---\n\n## 🔗 다음 장으로\n\n이번 장에서 배운 것:\n- ✅ 디지털 입력의 개념 (0 또는 1)\n- ✅ 풀다운 저항의 필요성\n- ✅ `Pin.IN`과 `Pin.PULL_DOWN` 사용법\n- ✅ 버튼 상태 읽기와 변화 감지\n\n**다음 장 예고**: 버튼으로 LED 제어하기! 🎮💡\n\n버튼을 누르면 LED가 켜지고, 떼면 꺼지는 **버튼-LED 연동**을 만들어볼 거예요. \n그리고 버튼 한 번 누를 때마다 LED가 토글되는 **스위치 기능**도 구현해봐요!",
      "tokens_used": 18505,
      "input_tokens": 13354,
      "output_tokens": 5151
    },
    {
      "success": true,
      "chapter_id": "chapter08",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter08.md",
      "content": "# 챕터 8: 누르면 반응해! - 조건문 활용\n\n> **Part 3**: 입력을 받아라 - 버튼과 상호작용\n\n---\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] if-else 조건문의 구조와 동작을 이해할 수 있다\n- [ ] 버튼을 누르면 LED가 켜지는 프로그램을 작성할 수 있다\n- [ ] 토글 기능(누를 때마다 상태 변경)을 구현할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n여러분 집에 있는 전등 스위치를 생각해보세요. 누르면 켜지고, 다시 누르면 꺼지죠? 이게 바로 **조건문**의 핵심입니다!\n\n프로그램이 똑똑해지려면 \"상황에 따라 다르게 행동\"해야 해요:\n- 버튼이 눌렸으면 → LED 켜기\n- 버튼이 안 눌렸으면 → LED 끄기\n\n이런 **\"만약 ~라면, ~해라\"** 논리를 코드로 표현하는 게 조건문이에요. 조건문 없이는 스마트폰도, 게임도, 자동문도 만들 수 없답니다!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 조건문 (if-else)\n\n1. **비유로 시작**: \"조건문은 마치 갈림길의 이정표와 같아요. '비가 오면 우산을 쓰고, 안 오면 그냥 가라'처럼요!\"\n\n2. **정확한 정의**: \"조건문은 주어진 조건이 참(True)인지 거짓(False)인지에 따라 다른 코드를 실행하는 구조입니다.\"\n\n3. **예시로 확인**:\n```python\nif 버튼이_눌렸다:\n    LED를_켠다\nelse:\n    LED를_끈다\n```\n\n**쉽게 말하면**: 조건문 = \"만약 ~라면 A하고, 아니면 B해라\"\n\n```mermaid\nflowchart TD\n    A[🔘 버튼 상태 확인] --> B{눌렸나요?}\n    B -->|Yes| C[💡 LED 켜기]\n    B -->|No| D[⚫ LED 끄기]\n    C --> E[🔄 다시 확인]\n    D --> E\n    E --> A\n    \n    style A fill:#e3f2fd,stroke:#1976d2\n    style B fill:#fff3e0,stroke:#f57c00\n    style C fill:#c8e6c9,stroke:#388e3c\n    style D fill:#ffcdd2,stroke:#d32f2f\n    style E fill:#f3e5f5,stroke:#7b1fa2\n```\n\n### 개념 2: 토글(Toggle)\n\n1. **비유로 시작**: \"토글은 형광등 스위치예요. 한 번 누르면 켜지고, 다시 누르면 꺼지죠!\"\n\n2. **정확한 정의**: \"토글은 한 번의 입력으로 상태를 반대로 바꾸는 동작입니다. ON→OFF, OFF→ON\"\n\n3. **예시로 확인**: \n   - 1번째 누름: 꺼짐 → 켜짐\n   - 2번째 누름: 켜짐 → 꺼짐\n   - 3번째 누름: 꺼짐 → 켜짐\n\n**쉽게 말하면**: 토글 = \"누를 때마다 반대로!\"\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 버튼 누르면 LED 켜기\n\n**목표**: 버튼을 누르고 있는 동안만 LED가 켜지게 만들기\n\n**회로 연결**:\n- Grove 버튼 → D20 포트\n- Grove LED → D18 포트\n\n```mermaid\nflowchart LR\n    subgraph 피코[\"🔧 Pico 2W\"]\n        D20[D20 포트]\n        D18[D18 포트]\n    end\n    \n    BTN[🔘 버튼] --> D20\n    D18 --> LED[💡 LED]\n    \n    style 피코 fill:#e8f5e9,stroke:#388e3c\n    style BTN fill:#fff3e0,stroke:#f57c00\n    style LED fill:#ffecb3,stroke:#ffa000\n```\n\n**코드**:\n```python\n# === WHAT: 버튼으로 LED 제어하기 ===\n# 버튼을 누르면 LED가 켜지고, 떼면 꺼져요\n\n# --- WHY: 왜 필요한지 ---\n# 입력(버튼)에 따라 출력(LED)을 제어하는 기본기를 배워요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin  # 핀 제어 라이브러리\nimport time              # 시간 관련 기능\n\n# 버튼 설정: 입력 모드, 풀다운 저항 사용\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\n\n# LED 설정: 출력 모드\nled = Pin(18, Pin.OUT)\n\n# 무한 반복\nwhile True:\n    if button.value() == 1:  # 버튼이 눌렸으면 (1 = 눌림)\n        led.on()              # LED 켜기\n    else:                     # 버튼이 안 눌렸으면\n        led.off()             # LED 끄기\n    \n    time.sleep(0.1)  # 0.1초 대기 (CPU 부하 방지)\n```\n\n**실행 결과**:\n```\n버튼을 누르고 있으면 → LED 켜짐 💡\n버튼을 떼면 → LED 꺼짐 ⚫\n```\n\n**여기서 잠깐! 🤔**\n\n`Pin.PULL_DOWN`이 뭐냐고요? 버튼을 안 눌렀을 때 **확실하게 0**이 되도록 해주는 설정이에요. 이게 없으면 버튼 상태가 불안정해져서 LED가 깜빡거릴 수 있어요!\n\n---\n\n### Step 2: 토글 기능 구현하기\n\n**목표**: 버튼을 한 번 누르면 켜지고, 다시 누르면 꺼지게 만들기\n\n**핵심 아이디어**: LED의 현재 상태를 **변수에 기억**해두고, 버튼을 누를 때마다 **반대로** 바꿔요!\n\n```mermaid\nflowchart TD\n    A[🚀 시작: led_on = False] --> B[🔄 반복 시작]\n    B --> C{🔘 버튼 눌림?}\n    C -->|No| B\n    C -->|Yes| D{💡 led_on 상태?}\n    D -->|False| E[LED 켜기 + led_on = True]\n    D -->|True| F[LED 끄기 + led_on = False]\n    E --> G[⏳ 버튼 뗄 때까지 대기]\n    F --> G\n    G --> B\n    \n    style A fill:#e3f2fd,stroke:#1976d2\n    style C fill:#fff3e0,stroke:#f57c00\n    style D fill:#f3e5f5,stroke:#7b1fa2\n    style E fill:#c8e6c9,stroke:#388e3c\n    style F fill:#ffcdd2,stroke:#d32f2f\n```\n\n**코드**:\n```python\n# === WHAT: 토글 스위치 만들기 ===\n# 버튼을 누를 때마다 LED가 켜졌다 꺼졌다 해요\n\n# --- WHY: 왜 필요한지 ---\n# 실제 전등 스위치처럼 동작하는 프로그램을 만들어요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin\nimport time\n\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\nled = Pin(18, Pin.OUT)\n\n# 💾 LED 상태를 기억하는 변수 (처음엔 꺼진 상태)\nled_on = False\n\nwhile True:\n    if button.value() == 1:  # 버튼이 눌렸으면\n        # 상태 반전! (True↔False)\n        if led_on == False:\n            led.on()\n            led_on = True\n            print(\"LED 켜짐! 💡\")\n        else:\n            led.off()\n            led_on = False\n            print(\"LED 꺼짐! ⚫\")\n        \n        # ⏳ 버튼을 뗄 때까지 대기 (중요!)\n        while button.value() == 1:\n            time.sleep(0.01)\n        \n        time.sleep(0.1)  # 디바운싱 (채터링 방지)\n```\n\n**실행 결과**:\n```\n(버튼 1번째 누름)\nLED 켜짐! 💡\n\n(버튼 2번째 누름)\nLED 꺼짐! ⚫\n\n(버튼 3번째 누름)\nLED 켜짐! 💡\n```\n\n**여기서 잠깐! 🤔**\n\n\"버튼을 뗄 때까지 대기\"하는 코드가 왜 필요할까요? \n\n버튼을 누르는 동안 `while True` 루프가 엄청 빠르게 돌아요. 그래서 한 번 눌렀는데 여러 번 눌린 것처럼 인식될 수 있어요! 이 대기 코드가 **한 번 누름 = 한 번 동작**을 보장해줍니다.\n\n---\n\n### Step 3: 더 깔끔한 토글 코드\n\n**목표**: `not` 연산자로 토글 코드를 간단하게!\n\n**코드**:\n```python\n# === WHAT: 깔끔한 토글 코드 ===\n# not 연산자로 상태를 한 줄에 반전!\n\nfrom machine import Pin\nimport time\n\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\nled = Pin(18, Pin.OUT)\n\nled_on = False\n\nwhile True:\n    if button.value() == 1:\n        # 🎯 핵심: not으로 True↔False 반전!\n        led_on = not led_on\n        \n        # LED 상태 적용\n        if led_on:\n            led.on()\n        else:\n            led.off()\n        \n        print(f\"LED 상태: {'켜짐 💡' if led_on else '꺼짐 ⚫'}\")\n        \n        # 버튼 뗄 때까지 대기\n        while button.value() == 1:\n            time.sleep(0.01)\n        \n        time.sleep(0.1)\n```\n\n**`not` 연산자란?**\n- `not True` → `False`\n- `not False` → `True`\n\n한 줄로 상태를 뒤집을 수 있어서 코드가 훨씬 깔끔해져요!\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 토글 LED 스위치 - 완성 버전 ===\n# 버튼을 누를 때마다 LED가 켜졌다 꺼졌다 합니다\n# \n# 연결:\n#   - Grove 버튼 → D20 포트\n#   - Grove LED → D18 포트\n\nfrom machine import Pin\nimport time\n\n# 하드웨어 설정\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)  # 버튼: 입력\nled = Pin(18, Pin.OUT)                    # LED: 출력\n\n# 상태 변수\nled_on = False\n\nprint(\"🔘 토글 스위치 프로그램 시작!\")\nprint(\"버튼을 눌러 LED를 켜고 끄세요.\\n\")\n\nwhile True:\n    # 버튼이 눌렸는지 확인\n    if button.value() == 1:\n        # 상태 반전\n        led_on = not led_on\n        \n        # LED에 상태 적용\n        if led_on:\n            led.on()\n            print(\"💡 LED ON\")\n        else:\n            led.off()\n            print(\"⚫ LED OFF\")\n        \n        # 버튼에서 손 뗄 때까지 대기\n        while button.value() == 1:\n            time.sleep(0.01)\n        \n        # 디바운싱\n        time.sleep(0.1)\n    \n    time.sleep(0.01)  # CPU 부하 방지\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 버튼 한 번 눌렀는데 여러 번 동작해요!\n\n**증상**: 버튼을 한 번만 눌렀는데 LED가 막 깜빡거림\n\n**원인**: 버튼에서 손 뗄 때까지 기다리는 코드가 없어서, 루프가 빠르게 돌면서 여러 번 인식됨\n\n**해결**:\n```python\n# ❌ 잘못된 코드\nif button.value() == 1:\n    led_on = not led_on\n    # 바로 다음 루프로 넘어감 → 계속 눌린 걸로 인식!\n\n# ✅ 올바른 코드\nif button.value() == 1:\n    led_on = not led_on\n    \n    # 버튼 뗄 때까지 대기!\n    while button.value() == 1:\n        time.sleep(0.01)\n```\n\n### 실수 2: LED 상태가 안 바뀌어요!\n\n**증상**: 버튼을 눌러도 LED가 계속 꺼져있거나 계속 켜져있음\n\n**원인**: `led.on()`/`led.off()`를 빠뜨림 (변수만 바꾸고 실제 LED는 안 바꿈)\n\n**해결**:\n```python\n# ❌ 잘못된 코드\nled_on = not led_on  # 변수만 바꿈\n# LED는 그대로!\n\n# ✅ 올바른 코드\nled_on = not led_on  # 변수 바꾸고\nif led_on:\n    led.on()   # 실제 LED도 켜기!\nelse:\n    led.off()  # 실제 LED도 끄기!\n```\n\n### 실수 3: `PULL_DOWN` 빠뜨림\n\n**증상**: 버튼을 안 눌러도 LED가 불규칙하게 반응함\n\n**원인**: 풀다운 저항 없이 버튼 입력이 불안정함 (플로팅 상태)\n\n**해결**:\n```python\n# ❌ 잘못된 코드\nbutton = Pin(20, Pin.IN)  # 풀다운 없음 → 불안정!\n\n# ✅ 올바른 코드\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)  # 풀다운 추가!\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **if-else 문에서 조건이 참(True)일 때 실행되는 부분은 어디인가요?**\n\n2. **토글 기능을 구현할 때 왜 상태를 저장하는 변수가 필요한가요?**\n\n3. **`not True`의 결과는 무엇인가요?**\n\n4. **버튼을 뗄 때까지 대기하는 코드가 없으면 어떤 문제가 생기나요?**\n\n<details>\n<summary>정답 확인</summary>\n\n1. `if` 바로 다음에 들여쓰기된 코드 블록이 실행됩니다.\n\n2. 버튼을 누를 때마다 \"현재 LED가 켜져있는지 꺼져있는지\"를 알아야 반대 동작을 할 수 있기 때문이에요. 기억이 없으면 매번 \"켜!\"만 하게 됩니다.\n\n3. `False`입니다. `not`은 참/거짓을 반대로 뒤집어요.\n\n4. 버튼을 한 번만 눌러도 루프가 빠르게 돌면서 여러 번 눌린 것처럼 인식되어, LED가 깜빡거립니다.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: LED 2개 토글 (쉬움)\n버튼을 누를 때마다 두 개의 LED가 번갈아 켜지게 만들어보세요!\n- 1번 누름: LED1 켜짐, LED2 꺼짐\n- 2번 누름: LED1 꺼짐, LED2 켜짐\n\n### 도전 2: 버튼 카운터 (중간)\n버튼을 누른 횟수를 세서 출력해보세요.\n```\n버튼 눌림! 총 1번\n버튼 눌림! 총 2번\n버튼 눌림! 총 3번\n```\n힌트: `count = count + 1` 또는 `count += 1`\n\n### 도전 3: 길게 누르기 vs 짧게 누르기 (어려움) ⭐\n- 짧게 누르면(1초 미만): LED 토글\n- 길게 누르면(1초 이상): LED 3번 깜빡이기\n\n힌트: `time.ticks_ms()`로 시간을 잴 수 있어요!\n\n---\n\n## 🔗 다음 장으로\n\n축하해요! 🎉 이번 장에서 배운 것:\n- **if-else 조건문**으로 상황에 따라 다르게 동작하기\n- **버튼 입력**을 읽어서 **LED 출력** 제어하기\n- **토글 기능**으로 누를 때마다 상태 바꾸기\n- **상태 변수**로 현재 상태 기억하기\n\n다음 장에서는 **센서로 세상 읽기**를 배워요! 온도, 습도, 밝기... 피코가 주변 환경을 느끼고 반응하게 만들어봐요. 버튼은 사람이 직접 눌러야 하지만, 센서는 **자동으로** 환경을 감지한답니다! 🌡️",
      "tokens_used": 18879,
      "input_tokens": 13375,
      "output_tokens": 5504
    },
    {
      "success": true,
      "chapter_id": "chapter09",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter09.md",
      "content": "# Chapter 9: 반응속도 게임 만들기\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] `time.ticks_ms()` 함수로 시간을 측정할 수 있다\n- [ ] `random` 모듈로 예측 불가능한 대기 시간을 만들 수 있다\n- [ ] 버튼과 LED를 조합해 반응속도 게임을 완성할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n스마트폰 게임에서 \"정확한 타이밍에 터치하세요!\"라는 미션을 본 적 있나요? 이런 게임들은 모두 **시간 측정**과 **랜덤 이벤트**를 활용합니다.\n\n오늘 배울 기술은 게임뿐 아니라 실제로도 많이 쓰여요:\n- 🏃 체육 시간의 반응속도 측정\n- 🚗 자동차 급정거 시스템의 반응 시간\n- 🎮 게임 컨트롤러의 입력 지연 측정\n\n무엇보다, **친구들과 \"누가 더 빠른가\" 대결**을 할 수 있어요! 🏆\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 시간 측정 (time.ticks_ms)\n\n1. **비유로 시작**: 스톱워치를 생각해보세요. 시작 버튼을 누르고, 멈춤 버튼을 누르면 그 사이 시간이 나오죠? `ticks_ms()`가 바로 그 스톱워치예요.\n\n2. **정확한 정의**: `time.ticks_ms()`는 피코가 켜진 후 지난 시간을 **밀리초(1/1000초)** 단위로 알려주는 함수입니다.\n\n3. **예시로 확인**:\n```python\nimport time\n시작 = time.ticks_ms()  # 지금 시간 기록\ntime.sleep(1)           # 1초 대기\n끝 = time.ticks_ms()    # 다시 시간 기록\n경과 = time.ticks_diff(끝, 시작)  # 차이 계산\nprint(f\"경과 시간: {경과}ms\")  # 약 1000ms 출력\n```\n\n**쉽게 말하면**: 시작 시간을 기록하고, 끝 시간을 기록한 뒤, 둘의 차이를 구하면 경과 시간이에요!\n\n---\n\n### 개념 2: 랜덤 함수 (random)\n\n1. **비유로 시작**: 주사위를 던지면 1~6 중 어떤 숫자가 나올지 모르죠? `random`은 컴퓨터가 주사위를 던지는 거예요.\n\n2. **정확한 정의**: `random` 모듈은 예측할 수 없는 무작위 숫자를 만들어주는 기능입니다.\n\n3. **예시로 확인**:\n```python\nimport random\n대기시간 = random.randint(2, 5)  # 2~5 중 무작위 숫자\nprint(f\"대기 시간: {대기시간}초\")\n```\n\n**쉽게 말하면**: `randint(최소, 최대)`는 그 범위 안에서 무작위 정수를 골라줘요!\n\n---\n\n### 개념 흐름 한눈에 보기\n\n```mermaid\nflowchart LR\n    A[🎲 랜덤 대기] --> B[💡 LED 켜짐]\n    B --> C[⏱️ 시간 측정 시작]\n    C --> D[🔘 버튼 누름]\n    D --> E[📊 반응시간 계산]\n    \n    style A fill:#fff3e0,stroke:#f57c00\n    style B fill:#ffecb3,stroke:#ffa000\n    style C fill:#e3f2fd,stroke:#1976d2\n    style D fill:#e8f5e9,stroke:#388e3c\n    style E fill:#f3e5f5,stroke:#7b1fa2\n```\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 시간 측정 연습\n\n**목표**: 버튼을 누르는 데 걸린 시간 측정하기\n\n**회로 연결**:\n- Grove 버튼 → D20 포트\n- Grove LED → D18 포트\n\n```mermaid\nflowchart LR\n    subgraph Pico[\"🟢 Pico 2W\"]\n        D20[D20 포트]\n        D18[D18 포트]\n    end\n    \n    subgraph Components[\"부품\"]\n        BTN[🔘 버튼]\n        LED[💡 LED]\n    end\n    \n    D20 --> BTN\n    D18 --> LED\n    \n    style Pico fill:#e8f5e9,stroke:#388e3c\n    style Components fill:#fff3e0,stroke:#f57c00\n```\n\n**코드**:\n```python\n# === WHAT: 버튼 누르는 시간 측정 ===\n# 버튼을 누르면 얼마나 걸렸는지 알려주는 코드\n\n# --- WHY: 왜 필요한지 ---\n# 반응속도 게임의 핵심! 시간 측정 방법을 먼저 익혀요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin\nimport time\n\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)  # 버튼: D20\n\nprint(\"버튼을 누르세요!\")\n시작시간 = time.ticks_ms()  # 지금 시간 기록\n\nwhile button.value() == 0:  # 버튼 안 눌린 동안 대기\n    pass\n\n끝시간 = time.ticks_ms()  # 버튼 눌린 시간 기록\n걸린시간 = time.ticks_diff(끝시간, 시작시간)\n\nprint(f\"걸린 시간: {걸린시간}ms\")\n```\n\n**실행 결과**:\n```\n버튼을 누르세요!\n걸린 시간: 2341ms\n```\n\n**여기서 잠깐! 🤔**\n`ticks_diff()`를 쓰는 이유가 있어요. 단순히 `끝-시작`으로 계산하면 오버플로우 문제가 생길 수 있거든요. `ticks_diff()`가 이걸 안전하게 처리해줍니다!\n\n---\n\n### Step 2: 랜덤 대기 시간 추가\n\n**목표**: 예측 불가능한 시점에 LED 켜기\n\n**코드**:\n```python\n# === WHAT: 랜덤 시간 후 LED 켜기 ===\n# 언제 켜질지 모르니까 긴장하게 만드는 코드\n\n# --- WHY: 왜 필요한지 ---\n# 타이밍을 예측할 수 있으면 게임이 안 돼요!\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin\nimport time\nimport random\n\nled = Pin(18, Pin.OUT)    # LED: D18\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\n\nprint(\"LED가 켜지면 버튼을 누르세요!\")\nprint(\"준비...\")\n\n대기시간 = random.randint(2, 5)  # 2~5초 중 랜덤\ntime.sleep(대기시간)\n\nled.on()  # LED 켜기\n시작시간 = time.ticks_ms()\n\nwhile button.value() == 0:\n    pass\n\n끝시간 = time.ticks_ms()\nled.off()\n\n반응시간 = time.ticks_diff(끝시간, 시작시간)\nprint(f\"반응 시간: {반응시간}ms\")\n```\n\n**실행 결과**:\n```\nLED가 켜지면 버튼을 누르세요!\n준비...\n(2~5초 후 LED 켜짐)\n반응 시간: 287ms\n```\n\n**여기서 잠깐! 🤔**\n평균 반응속도는 200~300ms 정도예요. 200ms 이하면 꽤 빠른 편이고, 150ms 이하면 프로게이머급!\n\n---\n\n### Step 3: 부정행위 방지하기\n\n**목표**: LED 켜지기 전에 누르면 \"부정행위!\" 출력\n\n**코드**:\n```python\n# === WHAT: 부정행위 감지 기능 추가 ===\n# 미리 누르면 잡아내는 코드\n\n# --- WHY: 왜 필요한지 ---\n# 공정한 게임을 위해 필수!\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin\nimport time\nimport random\n\nled = Pin(18, Pin.OUT)\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\n\nprint(\"LED가 켜지면 버튼을 누르세요!\")\nprint(\"준비...\")\n\n대기시간 = random.randint(2, 5)\n\n# 대기 중 버튼 체크\nfor i in range(대기시간 * 10):  # 0.1초 단위로 체크\n    if button.value() == 1:\n        print(\"🚫 부정행위! 너무 빨리 눌렀어요!\")\n        led.off()\n        raise SystemExit  # 프로그램 종료\n    time.sleep(0.1)\n\nled.on()\n시작시간 = time.ticks_ms()\n\nwhile button.value() == 0:\n    pass\n\n끝시간 = time.ticks_ms()\nled.off()\n\n반응시간 = time.ticks_diff(끝시간, 시작시간)\nprint(f\"✅ 반응 시간: {반응시간}ms\")\n```\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 반응속도 게임 완성판 ===\n# 버튼: D20, LED: D18에 연결하세요\n\nfrom machine import Pin\nimport time\nimport random\n\n# 핀 설정\nled = Pin(18, Pin.OUT)\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\n\ndef 게임시작():\n    print(\"\\n🎮 반응속도 게임!\")\n    print(\"LED가 켜지면 최대한 빨리 버튼을 누르세요!\")\n    print(\"=\" * 30)\n    \n    for 라운드 in range(1, 4):  # 3라운드\n        print(f\"\\n[라운드 {라운드}] 준비...\")\n        time.sleep(1)\n        \n        대기시간 = random.randint(2, 5)\n        부정행위 = False\n        \n        # 대기 중 버튼 체크\n        for i in range(대기시간 * 10):\n            if button.value() == 1:\n                print(\"🚫 부정행위! 다시 시도하세요.\")\n                부정행위 = True\n                break\n            time.sleep(0.1)\n        \n        if 부정행위:\n            continue  # 다음 라운드로\n        \n        # LED 켜고 시간 측정\n        led.on()\n        시작 = time.ticks_ms()\n        \n        while button.value() == 0:\n            pass\n        \n        끝 = time.ticks_ms()\n        led.off()\n        \n        반응시간 = time.ticks_diff(끝, 시작)\n        \n        # 결과 출력\n        if 반응시간 < 200:\n            print(f\"⚡ {반응시간}ms - 번개같이 빨라요!\")\n        elif 반응시간 < 300:\n            print(f\"✨ {반응시간}ms - 좋은 반응속도!\")\n        else:\n            print(f\"👍 {반응시간}ms - 다음엔 더 빨리!\")\n        \n        time.sleep(1)\n    \n    print(\"\\n🏁 게임 종료!\")\n\n# 게임 실행\n게임시작()\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 시간 차이 계산을 잘못함\n\n**증상**: 음수가 나오거나 이상한 값이 나옴\n\n**원인**: 단순 뺄셈 사용\n\n**해결**:\n```python\n# 잘못된 코드\n걸린시간 = 끝시간 - 시작시간\n\n# 올바른 코드\n걸린시간 = time.ticks_diff(끝시간, 시작시간)\n```\n\n---\n\n### 실수 2: 버튼 상태 체크 조건 오류\n\n**증상**: 버튼을 안 눌러도 바로 통과됨\n\n**원인**: PULL_DOWN 설정 누락 또는 조건문 방향 오류\n\n**해결**:\n```python\n# 잘못된 코드\nbutton = Pin(20, Pin.IN)  # PULL_DOWN 없음\nwhile button.value() == 1:  # 조건 반대\n    pass\n\n# 올바른 코드\nbutton = Pin(20, Pin.IN, Pin.PULL_DOWN)\nwhile button.value() == 0:  # 0일 때 = 안 눌림\n    pass\n```\n\n---\n\n### 실수 3: random 모듈 import 누락\n\n**증상**: `NameError: name 'random' is not defined`\n\n**원인**: import 문 빠뜨림\n\n**해결**:\n```python\n# 잘못된 코드\n대기시간 = random.randint(2, 5)  # 오류!\n\n# 올바른 코드\nimport random  # 꼭 추가!\n대기시간 = random.randint(2, 5)\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **`time.ticks_ms()`는 무엇을 반환하나요?**\n\n2. **`random.randint(1, 10)`이 반환할 수 있는 값의 범위는?**\n\n3. **왜 `ticks_diff()` 함수를 사용해야 하나요?**\n\n<details>\n<summary>정답 확인</summary>\n\n1. 피코가 켜진 후 지난 시간을 **밀리초(ms)** 단위로 반환합니다.\n\n2. **1부터 10까지** (1과 10 포함)\n\n3. 단순 뺄셈은 시간 값이 최대치를 넘어가면(오버플로우) 잘못된 결과가 나올 수 있어요. `ticks_diff()`는 이를 안전하게 처리해줍니다.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 최고 기록 저장하기\n3라운드 중 가장 빠른 기록을 저장하고 마지막에 출력해보세요.\n\n**힌트**: `min()` 함수와 리스트 활용\n\n---\n\n### 도전 2: 평균 반응시간 계산\n3라운드의 평균 반응시간을 계산해서 출력해보세요.\n\n**힌트**: 리스트에 기록 저장 → `sum() / len()` 계산\n\n---\n\n### 도전 3: 2인용 대결 모드 ⭐\n버튼 2개를 사용해서 누가 먼저 누르는지 대결하는 모드를 만들어보세요!\n\n**힌트**: 버튼 2개 설정, `while` 루프에서 둘 다 체크\n\n---\n\n## 🔗 다음 장으로\n\n오늘 배운 것:\n- ⏱️ `time.ticks_ms()`로 정밀한 시간 측정\n- 🎲 `random.randint()`로 예측 불가능한 동작 구현\n- 🎮 버튼과 LED를 조합한 인터랙티브 게임 완성!\n\n**다음 장 예고**: 이제 진짜 \"화면\"에 정보를 표시해볼 거예요! OLED 디스플레이를 연결해서 반응시간을 화면에 띄우고, 더 멋진 프로젝트를 만들어봅시다. 📺",
      "tokens_used": 18136,
      "input_tokens": 13355,
      "output_tokens": 4781
    },
    {
      "success": true,
      "chapter_id": "chapter10",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter10.md",
      "content": "# 삐- 소리의 원리 - 부저 연결과 PWM\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 피에조 부저가 소리를 내는 원리를 설명할 수 있다\n- [ ] PWM(펄스 폭 변조)의 개념을 이해하고 설명할 수 있다\n- [ ] 주파수를 변경하여 다른 높이의 음을 연주할 수 있다\n- [ ] 간단한 멜로디를 코드로 만들어 재생할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n알람 시계가 울릴 때, 전자레인지가 \"삐-\" 할 때, 게임에서 효과음이 날 때... 이 모든 소리는 어떻게 만들어질까요?\n\n피에조 부저는 가장 단순한 형태의 전자 스피커입니다. 전기 신호를 주면 진동해서 소리를 냅니다. 그리고 이 진동 속도를 조절하면 **높은 음, 낮은 음**을 자유롭게 만들 수 있어요!\n\n이번 장에서 배울 **PWM(Pulse Width Modulation)** 기술은 부저뿐 아니라 LED 밝기 조절, 모터 속도 제어 등 피지컬 컴퓨팅의 핵심 기술입니다. 소리라는 재미있는 결과물로 PWM을 익혀봅시다!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 피에조 부저의 원리\n\n1. **비유로 시작**: 피에조 부저는 마치 **빠르게 떨리는 딱지**와 같아요. 딱지를 천천히 튕기면 낮은 소리, 빠르게 튕기면 높은 소리가 나죠?\n\n2. **정확한 정의**: 피에조 부저는 전기 신호를 받으면 내부의 얇은 판(진동판)이 움직여서 공기를 진동시키고, 이 진동이 우리 귀에 소리로 들립니다.\n\n3. **예시로 확인**: \n   - 1초에 262번 진동 → \"도\" 음\n   - 1초에 440번 진동 → \"라\" 음 (기준음)\n   - 1초에 523번 진동 → 높은 \"도\" 음\n\n**쉽게 말하면**: 전기로 판을 빠르게 떨어서 소리를 만드는 장치입니다!\n\n```mermaid\nflowchart LR\n    A[⚡ 전기 신호] --> B[📳 진동판 움직임]\n    B --> C[🌊 공기 진동]\n    C --> D[👂 소리]\n    \n    style A fill:#fff3e0,stroke:#f57c00\n    style B fill:#e3f2fd,stroke:#1976d2\n    style C fill:#f3e5f5,stroke:#7b1fa2\n    style D fill:#e8f5e9,stroke:#388e3c\n```\n\n---\n\n### 개념 2: 주파수와 음높이\n\n1. **비유로 시작**: 주파수는 마치 **줄넘기 속도**와 같아요. 1초에 몇 번 줄을 돌리는지가 주파수예요.\n\n2. **정확한 정의**: 주파수(Hz, 헤르츠)는 1초 동안 진동하는 횟수입니다. 주파수가 높을수록 높은 음, 낮을수록 낮은 음이 납니다.\n\n3. **예시로 확인**:\n\n| 음이름 | 주파수(Hz) | 느낌 |\n|:---:|:---:|:---:|\n| 도(C4) | 262 | 기본 |\n| 레(D4) | 294 | 조금 높음 |\n| 미(E4) | 330 | |\n| 파(F4) | 349 | |\n| 솔(G4) | 392 | |\n| 라(A4) | 440 | 기준음! |\n| 시(B4) | 494 | |\n| 높은도(C5) | 523 | 한 옥타브 위 |\n\n**쉽게 말하면**: 1초에 몇 번 떨리는지 = 주파수, 많이 떨릴수록 높은 소리!\n\n---\n\n### 개념 3: PWM (펄스 폭 변조)\n\n1. **비유로 시작**: PWM은 마치 **빠르게 껐다 켰다 하는 스위치**와 같아요. 너무 빨라서 우리 눈(귀)에는 연속적으로 느껴지죠.\n\n2. **정확한 정의**: PWM은 디지털 신호(0 또는 1)를 아주 빠르게 켜고 꺼서 마치 중간값(아날로그)처럼 만드는 기술입니다.\n\n3. **예시로 확인**:\n   - LED에 PWM 적용 → 밝기 조절 (50% 켜짐 = 반만 밝음)\n   - 부저에 PWM 적용 → 특정 주파수로 소리 발생\n\n```mermaid\nflowchart TB\n    subgraph PWM신호\n        direction LR\n        A[\"켜짐 ████\"] --> B[\"꺼짐 ____\"]\n        B --> C[\"켜짐 ████\"]\n        C --> D[\"꺼짐 ____\"]\n    end\n    \n    E[🔊 PWM으로 부저 제어] --> F[주파수 = 음높이]\n    E --> G[듀티사이클 = 음량]\n    \n    style E fill:#e3f2fd,stroke:#1976d2\n    style F fill:#fff3e0,stroke:#f57c00\n    style G fill:#e8f5e9,stroke:#388e3c\n```\n\n**쉽게 말하면**: 엄청 빠르게 껐다켜서 원하는 효과를 만드는 기술!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 부저 연결하기\n\n**목표**: Grove 부저를 피코에 연결합니다.\n\nGrove 부저를 **D20 포트**에 연결하세요. Grove 케이블을 사용하면 핀 연결을 고민할 필요 없이 포트에 꽂기만 하면 됩니다!\n\n```mermaid\nflowchart LR\n    subgraph 피코[\"🔌 Pico + Grove Shield\"]\n        D20[\"D20 포트\"]\n    end\n    \n    subgraph 부저[\"🔔 Grove Buzzer\"]\n        SIG[\"신호선\"]\n    end\n    \n    D20 <-->|Grove 케이블| SIG\n    \n    style 피코 fill:#e3f2fd,stroke:#1976d2\n    style 부저 fill:#fff3e0,stroke:#f57c00\n```\n\n**여기서 잠깐! 🤔**  \nGrove Shield의 D20 포트는 GP20 핀에 연결되어 있어요. 코드에서는 `Pin(20)`으로 접근합니다.\n\n---\n\n### Step 2: 첫 소리 내기 - \"삐-\"\n\n**목표**: 가장 간단한 방법으로 부저 소리를 냅니다.\n\n**코드**:\n```python\n# === WHAT: 부저로 \"삐-\" 소리 내기 ===\n# 가장 기본적인 부저 테스트 코드입니다\n\n# --- WHY: 부저가 제대로 연결됐는지 확인 ---\n# PWM 없이 단순히 켜고 끄는 것만으로도 소리가 납니다\n\nfrom machine import Pin, PWM  # 핀 제어와 PWM 기능\nimport time                    # 시간 지연용\n\n# 부저를 PWM 모드로 설정 (GP20 핀)\nbuzzer = PWM(Pin(20))\n\n# 주파수 설정: 1000Hz = 1초에 1000번 진동\nbuzzer.freq(1000)\n\n# 듀티 사이클: 32768 = 50% (최대값 65535의 절반)\nbuzzer.duty_u16(32768)\n\n# 0.5초 동안 소리 유지\ntime.sleep(0.5)\n\n# 소리 끄기: 듀티를 0으로\nbuzzer.duty_u16(0)\n\nprint(\"삐- 완료!\")\n```\n\n**실행 결과**:\n```\n삐- 완료!\n```\n(동시에 부저에서 0.5초간 \"삐-\" 소리가 납니다)\n\n**여기서 잠깐! 🤔**  \n- `freq(1000)`: 1초에 1000번 진동 = 1000Hz\n- `duty_u16(32768)`: 소리 크기 (0~65535 중 절반)\n- `duty_u16(0)`: 소리 끄기\n\n---\n\n### Step 3: 음계 연주하기 - \"도레미\"\n\n**목표**: 주파수를 바꿔서 다른 음을 냅니다.\n\n**코드**:\n```python\n# === WHAT: 도레미파솔라시도 연주하기 ===\n# 주파수를 바꿔서 다른 음높이를 만듭니다\n\n# --- WHY: 각 음은 고유한 주파수를 가짐 ---\n# 도=262Hz, 레=294Hz, 미=330Hz... 이렇게 정해져 있어요\n\nfrom machine import Pin, PWM\nimport time\n\nbuzzer = PWM(Pin(20))\n\n# 음계별 주파수 (Hz)\nnotes = {\n    'C4': 262,  # 도\n    'D4': 294,  # 레\n    'E4': 330,  # 미\n    'F4': 349,  # 파\n    'G4': 392,  # 솔\n    'A4': 440,  # 라\n    'B4': 494,  # 시\n    'C5': 523   # 높은 도\n}\n\n# 음을 연주하는 함수\ndef play_tone(frequency, duration):\n    \"\"\"주어진 주파수로 duration초 동안 소리를 냅니다\"\"\"\n    buzzer.freq(frequency)      # 주파수 설정\n    buzzer.duty_u16(32768)      # 소리 켜기\n    time.sleep(duration)        # 지정 시간 대기\n    buzzer.duty_u16(0)          # 소리 끄기\n    time.sleep(0.05)            # 음 사이 짧은 쉼\n\n# 도레미파솔라시도 연주!\nprint(\"🎵 도레미파솔라시도 연주 시작!\")\n\nfor note_name, freq in notes.items():\n    print(f\"  {note_name}: {freq}Hz\")\n    play_tone(freq, 0.3)  # 0.3초씩 연주\n\nprint(\"🎵 연주 완료!\")\n```\n\n**실행 결과**:\n```\n🎵 도레미파솔라시도 연주 시작!\n  C4: 262Hz\n  D4: 294Hz\n  E4: 330Hz\n  F4: 349Hz\n  G4: 392Hz\n  A4: 440Hz\n  B4: 494Hz\n  C5: 523Hz\n🎵 연주 완료!\n```\n\n**여기서 잠깐! 🤔**  \n주파수가 높아질수록 음이 높아지는 것을 귀로 확인해보세요!\n\n---\n\n### Step 4: 간단한 멜로디 연주\n\n**목표**: \"학교종이 땡땡땡\" 멜로디를 연주합니다.\n\n**코드**:\n```python\n# === WHAT: \"학교종\" 멜로디 연주 ===\n# 음표 배열을 만들어 멜로디를 연주합니다\n\n# --- WHY: 실제 음악처럼 연주하려면 ---\n# 음의 순서와 길이를 배열로 정리하면 편합니다\n\nfrom machine import Pin, PWM\nimport time\n\nbuzzer = PWM(Pin(20))\n\n# 음계 주파수 정의\nC4, D4, E4, F4, G4, A4, B4, C5 = 262, 294, 330, 349, 392, 440, 494, 523\nREST = 0  # 쉼표 (소리 없음)\n\ndef play(freq, duration):\n    \"\"\"음을 연주하는 함수\"\"\"\n    if freq == 0:  # 쉼표\n        buzzer.duty_u16(0)\n    else:\n        buzzer.freq(freq)\n        buzzer.duty_u16(32768)\n    time.sleep(duration)\n    buzzer.duty_u16(0)\n    time.sleep(0.03)\n\n# \"학교종이 땡땡땡\" 멜로디\n# (솔솔라라 솔솔미- 솔솔미미 레레레-)\nmelody = [\n    (G4, 0.3), (G4, 0.3), (A4, 0.3), (A4, 0.3),\n    (G4, 0.3), (G4, 0.3), (E4, 0.6),\n    (G4, 0.3), (G4, 0.3), (E4, 0.3), (E4, 0.3),\n    (D4, 0.3), (D4, 0.3), (D4, 0.6)\n]\n\nprint(\"🎵 학교종이 땡땡땡 연주!\")\n\nfor note, duration in melody:\n    play(note, duration)\n\nprint(\"🎵 연주 끝!\")\n```\n\n**실행 결과**:\n```\n🎵 학교종이 땡땡땡 연주!\n🎵 연주 끝!\n```\n\n---\n\n## 📝 전체 코드\n\n아래 코드를 복사해서 바로 실행할 수 있습니다:\n\n```python\n# === 부저로 멜로디 연주하기 - 완성 코드 ===\n# Grove 부저를 D20 포트에 연결하세요\n\nfrom machine import Pin, PWM\nimport time\n\n# 부저 초기화\nbuzzer = PWM(Pin(20))\n\n# 음계 주파수 사전\nNOTES = {\n    'C4': 262, 'D4': 294, 'E4': 330, 'F4': 349,\n    'G4': 392, 'A4': 440, 'B4': 494, 'C5': 523,\n    'REST': 0\n}\n\ndef play_tone(note, duration):\n    \"\"\"음을 연주합니다\"\"\"\n    freq = NOTES.get(note, 0)\n    if freq == 0:\n        buzzer.duty_u16(0)\n    else:\n        buzzer.freq(freq)\n        buzzer.duty_u16(32768)\n    time.sleep(duration)\n    buzzer.duty_u16(0)\n    time.sleep(0.03)\n\ndef play_scale():\n    \"\"\"도레미파솔라시도 연주\"\"\"\n    print(\"🎵 음계 연주!\")\n    for note in ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5']:\n        play_tone(note, 0.25)\n\ndef play_school_bell():\n    \"\"\"학교종 연주\"\"\"\n    print(\"🎵 학교종이 땡땡땡!\")\n    song = [\n        ('G4', 0.3), ('G4', 0.3), ('A4', 0.3), ('A4', 0.3),\n        ('G4', 0.3), ('G4', 0.3), ('E4', 0.5),\n        ('G4', 0.3), ('G4', 0.3), ('E4', 0.3), ('E4', 0.3),\n        ('D4', 0.3), ('D4', 0.3), ('D4', 0.5)\n    ]\n    for note, dur in song:\n        play_tone(note, dur)\n\n# 실행\nplay_scale()\ntime.sleep(0.5)\nplay_school_bell()\nprint(\"✅ 완료!\")\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 소리가 안 난다\n\n**증상**: 코드 실행은 되는데 부저에서 소리가 안 남\n\n**원인**: \n- 연결 포트가 잘못됨\n- 듀티 사이클이 0으로 설정됨\n\n**해결**:\n```python\n# 잘못된 코드 - 포트 번호 오류\nbuzzer = PWM(Pin(16))  # D16이 아닌 D20에 연결했다면\n\n# 올바른 코드 - 연결한 포트 번호 확인\nbuzzer = PWM(Pin(20))  # D20 포트 = GP20\n```\n\n---\n\n### 실수 2: 이상한 음이 난다\n\n**증상**: 소리는 나는데 원하는 음이 아님\n\n**원인**: 주파수 값이 잘못됨\n\n**해결**:\n```python\n# 잘못된 코드 - 주파수 단위 착각\nbuzzer.freq(262000)  # 262000Hz는 초음파 영역!\n\n# 올바른 코드 - 올바른 주파수\nbuzzer.freq(262)  # 262Hz = 도(C4)\n```\n\n---\n\n### 실수 3: 소리가 안 꺼진다\n\n**증상**: 프로그램이 끝나도 부저가 계속 울림\n\n**원인**: 프로그램 종료 전 듀티를 0으로 안 함\n\n**해결**:\n```python\n# 잘못된 코드 - 끄는 코드 없음\nbuzzer.freq(440)\nbuzzer.duty_u16(32768)\ntime.sleep(1)\n# 프로그램 끝... 하지만 소리는 계속!\n\n# 올바른 코드 - 반드시 끄기\nbuzzer.freq(440)\nbuzzer.duty_u16(32768)\ntime.sleep(1)\nbuzzer.duty_u16(0)  # 소리 끄기!\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **피에조 부저는 어떻게 소리를 만드나요?**\n\n2. **주파수 440Hz는 어떤 음인가요?**\n\n3. **PWM에서 `duty_u16(0)`을 하면 어떻게 되나요?**\n\n4. **높은 \"도\"의 주파수가 낮은 \"도\"보다 큰 이유는 무엇인가요?**\n\n<details>\n<summary>정답 확인</summary>\n\n1. 전기 신호를 받으면 내부 진동판이 빠르게 떨려서 공기를 진동시키고, 이것이 소리가 됩니다.\n\n2. 440Hz는 \"라(A4)\" 음입니다. 음악에서 기준음으로 사용됩니다.\n\n3. 듀티를 0으로 설정하면 PWM 신호가 완전히 꺼져서 소리가 나지 않습니다.\n\n4. 높은 음은 1초에 더 많이 진동해야 하므로 주파수(진동 횟수)가 더 높습니다. 높은 도(523Hz)는 낮은 도(262Hz)의 약 2배입니다.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 비프음 알림 만들기 (쉬움)\n버튼을 누르면 \"삐삐삐\" 3번 울리는 알림음을 만들어보세요.\n\n**힌트**: for문으로 3번 반복!\n\n---\n\n### 도전 2: 나만의 멜로디 작곡 (중간)\n좋아하는 노래의 일부분을 멜로디로 만들어보세요.\n\n**힌트**: 악보에서 음이름을 찾아 주파수로 변환하세요.\n\n---\n\n### 도전 3: 전자 피아노 만들기 ⭐ (어려움)\n버튼 여러 개를 연결해서 누르는 버튼에 따라 다른 음이 나는 전자 피아노를 만들어보세요.\n\n**힌트**: 버튼 입력(이전 장에서 배움) + 부저 출력을 결합!\n\n---\n\n## 🔗 다음 장으로\n\n축하합니다! 🎉 이번 장에서 배운 것들:\n\n- ✅ 피에조 부저의 원리 (전기 → 진동 → 소리)\n- ✅ 주파수와 음높이의 관계 (Hz가 높으면 음도 높음)\n- ✅ PWM으로 부저 제어하기\n- ✅ 멜로디 연주 코드 작성\n\n다음 장에서는 **버튼과 부저를 결합**해서 인터랙티브한 소리 장치를 만들어봅니다. 버튼을 누르면 다른 멜로디가 재생되는 \"효과음 장치\"를 만들 수 있어요!",
      "tokens_used": 19625,
      "input_tokens": 13364,
      "output_tokens": 6261
    },
    {
      "success": true,
      "chapter_id": "chapter11",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter11.md",
      "content": "# 챕터 11: 나만의 멜로디 - 학교종 연주하기\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 음계(도레미파솔라시도)와 주파수의 관계를 이해할 수 있다\n- [ ] 악보를 리스트 데이터로 변환할 수 있다\n- [ ] 함수를 만들어 코드를 깔끔하게 정리할 수 있다\n- [ ] 피코로 '학교종' 멜로디를 연주할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n지난 시간에 부저로 \"삐~\" 소리를 내봤죠? 이번에는 한 발 더 나아가 **진짜 멜로디**를 연주해봅니다!\n\n\"학교종이 땡땡땡~\" 🎵 이 노래, 아시죠? 이 간단한 동요를 피코가 연주하게 만들어볼 거예요.\n\n**이 과정에서 배우는 것들:**\n- **음악의 원리**: 왜 '도'와 '레'는 다른 소리일까? → 주파수!\n- **데이터 구조화**: 악보를 코드로 어떻게 표현할까? → 리스트!\n- **함수 만들기**: 반복되는 코드를 깔끔하게 → 함수!\n\n프로그래밍으로 음악을 만드는 경험, 생각보다 재밌어요! 🎹\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 음계와 주파수\n\n1. **비유로 시작**: \"음계는 마치 계단과 같아요\"\n   - 도레미파솔라시도는 8개의 계단\n   - 한 칸 올라갈 때마다 소리가 높아져요\n   - 이 \"높이\"를 결정하는 게 바로 **주파수**!\n\n2. **정확한 정의**: \"주파수는 1초에 공기가 몇 번 떨리는지예요\"\n   - 단위는 Hz (헤르츠)\n   - 숫자가 클수록 높은 음\n   - '도(C4)'는 약 262Hz, '레(D4)'는 약 294Hz\n\n3. **예시로 확인**:\n\n```mermaid\nflowchart LR\n    subgraph 음계\n    C[\"🎵 도<br/>262Hz\"] --> D[\"🎵 레<br/>294Hz\"] --> E[\"🎵 미<br/>330Hz\"] --> F[\"🎵 파<br/>349Hz\"]\n    F --> G[\"🎵 솔<br/>392Hz\"] --> A[\"🎵 라<br/>440Hz\"] --> B[\"🎵 시<br/>494Hz\"] --> C2[\"🎵 높은도<br/>523Hz\"]\n    end\n    style C fill:#ffcdd2,stroke:#e53935\n    style D fill:#ffe0b2,stroke:#fb8c00\n    style E fill:#fff9c4,stroke:#fdd835\n    style F fill:#c8e6c9,stroke:#43a047\n    style G fill:#b3e5fc,stroke:#039be5\n    style A fill:#d1c4e9,stroke:#7e57c2\n    style B fill:#f8bbd9,stroke:#ec407a\n    style C2 fill:#ffcdd2,stroke:#e53935\n```\n\n**쉽게 말하면**: 도레미파솔라시도는 각각 정해진 주파수(진동수)가 있고, 그 주파수를 부저에 보내면 해당 음이 나와요!\n\n---\n\n### 개념 2: 악보를 코드로 표현하기\n\n1. **비유로 시작**: \"악보는 마치 레시피와 같아요\"\n   - 레시피: \"당근 100g, 3분 볶기\"\n   - 악보: \"솔, 0.5초 연주\"\n   - 둘 다 **무엇을 + 얼마나**의 조합!\n\n2. **정확한 정의**: \"음 하나는 (주파수, 길이)의 쌍으로 표현해요\"\n   ```python\n   음표 = (주파수, 길이)\n   멜로디 = [음표1, 음표2, 음표3, ...]\n   ```\n\n3. **예시로 확인**: \"학교종\" 첫 소절\n   ```\n   악보: 솔솔라라 솔솔미\n   코드: [(392, 0.5), (392, 0.5), (440, 0.5), (440, 0.5), \n          (392, 0.5), (392, 0.5), (330, 1.0)]\n   ```\n\n**쉽게 말하면**: 리스트 안에 (주파수, 길이) 튜플을 넣으면 악보가 됩니다!\n\n---\n\n### 개념 3: 함수 - 코드 재사용의 마법\n\n1. **비유로 시작**: \"함수는 마치 자판기와 같아요\"\n   - 돈을 넣고(입력) → 버튼 누르면(호출) → 음료가 나와요(결과)\n   - 내부에서 어떻게 동작하는지 몰라도 사용 가능!\n\n2. **정확한 정의**: \"함수는 이름 붙인 코드 묶음이에요\"\n   ```python\n   def 함수이름(입력값):\n       실행할 코드\n       return 결과값  # 선택사항\n   ```\n\n3. **예시로 확인**:\n   ```python\n   # 함수 정의 (자판기 만들기)\n   def 인사하기(이름):\n       print(f\"안녕, {이름}!\")\n   \n   # 함수 호출 (자판기 사용)\n   인사하기(\"피코\")  # 출력: 안녕, 피코!\n   ```\n\n**쉽게 말하면**: 자주 쓰는 코드에 이름을 붙여두면, 그 이름만 불러서 재사용할 수 있어요!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 음계 사전 만들기\n\n**목표**: 도레미파솔라시도의 주파수를 저장하기\n\n**코드**:\n```python\n# === WHAT: 음계 주파수 정의 ===\n# 도레미파솔라시도 각 음의 주파수를 딕셔너리에 저장해요\n\n# --- WHY: 왜 필요한지 ---\n# 매번 숫자를 기억하기 어려우니까 이름으로 찾을 수 있게!\n\n# HOW: 어떻게 동작하는지\nnotes = {\n    'C4': 262,   # 도\n    'D4': 294,   # 레\n    'E4': 330,   # 미\n    'F4': 349,   # 파\n    'G4': 392,   # 솔\n    'A4': 440,   # 라\n    'B4': 494,   # 시\n    'C5': 523,   # 높은 도\n    'REST': 0    # 쉼표 (소리 없음)\n}\n\n# 테스트: 솔 음의 주파수 확인\nprint(\"솔(G4)의 주파수:\", notes['G4'], \"Hz\")\n```\n\n**실행 결과**:\n```\n솔(G4)의 주파수: 392 Hz\n```\n\n**여기서 잠깐! 🤔**\n딕셔너리를 쓰면 `notes['G4']`처럼 이름으로 주파수를 찾을 수 있어요. 숫자 392를 외우는 것보다 훨씬 편하죠?\n\n---\n\n### Step 2: 음 재생 함수 만들기\n\n**목표**: 한 음을 연주하는 함수 만들기\n\n**코드**:\n```python\n# === WHAT: 음 재생 함수 ===\n# 주파수와 길이를 받아서 부저로 소리 내는 함수\n\nfrom machine import Pin, PWM\nimport time\n\n# 부저 설정 (D20 포트)\nbuzzer = PWM(Pin(20))\n\n# --- WHY: 왜 함수로 만드나 ---\n# \"주파수 설정 → 대기 → 끄기\"를 매번 쓰기 귀찮으니까!\n\ndef play_tone(frequency, duration):\n    \"\"\"\n    한 음을 연주하는 함수\n    frequency: 주파수 (Hz)\n    duration: 길이 (초)\n    \"\"\"\n    if frequency == 0:  # 쉼표면\n        buzzer.duty_u16(0)  # 소리 끄기\n    else:\n        buzzer.freq(frequency)  # 주파수 설정\n        buzzer.duty_u16(30000)  # 소리 켜기\n    \n    time.sleep(duration)  # 길이만큼 대기\n    buzzer.duty_u16(0)    # 소리 끄기\n    time.sleep(0.05)      # 음 사이 짧은 쉼\n\n# 테스트: 도레미 연주\nplay_tone(262, 0.5)  # 도\nplay_tone(294, 0.5)  # 레\nplay_tone(330, 0.5)  # 미\n```\n\n**실행 결과**:\n```\n🔊 도~레~미~ 소리가 순서대로 납니다!\n```\n\n**여기서 잠깐! 🤔**\n`play_tone` 함수 하나로 어떤 음이든 연주할 수 있어요! 주파수와 길이만 바꿔서 호출하면 됩니다.\n\n---\n\n### Step 3: 학교종 악보를 코드로!\n\n**목표**: \"학교종\" 멜로디를 리스트로 만들기\n\n```mermaid\nflowchart TB\n    subgraph 악보[\"🎼 학교종 악보\"]\n    A[\"솔솔라라 솔솔미\"] --> B[\"솔솔미미 레~~\"]\n    B --> C[\"솔솔라라 솔솔미\"] --> D[\"솔미레미 도~~\"]\n    end\n    style 악보 fill:#fff3e0,stroke:#ff9800\n```\n\n**코드**:\n```python\n# === WHAT: 학교종 악보 데이터 ===\n# (음이름, 길이) 형태로 멜로디 저장\n\n# --- WHY: 왜 이렇게 ---\n# 리스트에 순서대로 넣으면 반복문으로 쭉 연주 가능!\n\n# 음계 딕셔너리 (Step 1에서 만든 것)\nnotes = {\n    'C4': 262, 'D4': 294, 'E4': 330, 'F4': 349,\n    'G4': 392, 'A4': 440, 'B4': 494, 'C5': 523,\n    'REST': 0\n}\n\n# 학교종 멜로디: (음이름, 박자)\n# 0.5 = 반박자, 1.0 = 한박자, 1.5 = 한박자 반\nschool_bell = [\n    # 1절: 솔솔라라 솔솔미\n    ('G4', 0.5), ('G4', 0.5), ('A4', 0.5), ('A4', 0.5),\n    ('G4', 0.5), ('G4', 0.5), ('E4', 1.0),\n    \n    # 2절: 솔솔미미 레~~\n    ('G4', 0.5), ('G4', 0.5), ('E4', 0.5), ('E4', 0.5),\n    ('D4', 1.5),\n    ('REST', 0.3),  # 짧은 쉼\n    \n    # 3절: 솔솔라라 솔솔미\n    ('G4', 0.5), ('G4', 0.5), ('A4', 0.5), ('A4', 0.5),\n    ('G4', 0.5), ('G4', 0.5), ('E4', 1.0),\n    \n    # 4절: 솔미레미 도~~\n    ('G4', 0.5), ('E4', 0.5), ('D4', 0.5), ('E4', 0.5),\n    ('C4', 1.5)\n]\n\nprint(\"악보 준비 완료! 음표 개수:\", len(school_bell))\n```\n\n**실행 결과**:\n```\n악보 준비 완료! 음표 개수: 25\n```\n\n---\n\n### Step 4: 멜로디 연주하기\n\n**목표**: 반복문으로 전체 멜로디 연주\n\n**코드**:\n```python\n# === WHAT: 멜로디 연주 함수 ===\n# 악보 리스트를 받아서 전체 연주\n\ndef play_melody(melody):\n    \"\"\"\n    멜로디 전체를 연주하는 함수\n    melody: [(음이름, 길이), ...] 형태의 리스트\n    \"\"\"\n    print(\"🎵 연주 시작!\")\n    \n    for note_name, duration in melody:\n        freq = notes[note_name]  # 음이름 → 주파수 변환\n        play_tone(freq, duration)\n    \n    print(\"🎵 연주 끝!\")\n\n# 학교종 연주!\nplay_melody(school_bell)\n```\n\n**여기서 잠깐! 🤔**\n`for note_name, duration in melody:` 이 부분이 핵심이에요!\n- `melody` 리스트에서 하나씩 꺼내서\n- `note_name`과 `duration`에 자동으로 나눠 담아요\n- 이걸 **언패킹(unpacking)**이라고 해요\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 🎵 학교종 연주 프로그램 ===\n# 피코가 \"학교종이 땡땡땡~\"을 연주합니다!\n\nfrom machine import Pin, PWM\nimport time\n\n# --- 부저 설정 ---\nbuzzer = PWM(Pin(20))  # D20 포트\n\n# --- 음계 주파수 딕셔너리 ---\nnotes = {\n    'C4': 262,   # 도\n    'D4': 294,   # 레\n    'E4': 330,   # 미\n    'F4': 349,   # 파\n    'G4': 392,   # 솔\n    'A4': 440,   # 라\n    'B4': 494,   # 시\n    'C5': 523,   # 높은 도\n    'REST': 0    # 쉼표\n}\n\n# --- 함수 정의 ---\ndef play_tone(frequency, duration):\n    \"\"\"한 음을 연주하는 함수\"\"\"\n    if frequency == 0:\n        buzzer.duty_u16(0)\n    else:\n        buzzer.freq(frequency)\n        buzzer.duty_u16(30000)\n    \n    time.sleep(duration)\n    buzzer.duty_u16(0)\n    time.sleep(0.05)\n\ndef play_melody(melody):\n    \"\"\"멜로디 전체를 연주하는 함수\"\"\"\n    print(\"🎵 연주 시작!\")\n    for note_name, duration in melody:\n        freq = notes[note_name]\n        play_tone(freq, duration)\n    print(\"🎵 연주 끝!\")\n\n# --- 학교종 악보 ---\nschool_bell = [\n    ('G4', 0.5), ('G4', 0.5), ('A4', 0.5), ('A4', 0.5),\n    ('G4', 0.5), ('G4', 0.5), ('E4', 1.0),\n    ('G4', 0.5), ('G4', 0.5), ('E4', 0.5), ('E4', 0.5),\n    ('D4', 1.5), ('REST', 0.3),\n    ('G4', 0.5), ('G4', 0.5), ('A4', 0.5), ('A4', 0.5),\n    ('G4', 0.5), ('G4', 0.5), ('E4', 1.0),\n    ('G4', 0.5), ('E4', 0.5), ('D4', 0.5), ('E4', 0.5),\n    ('C4', 1.5)\n]\n\n# --- 연주 실행 ---\nplay_melody(school_bell)\n\n# 정리\nbuzzer.deinit()\nprint(\"프로그램 종료\")\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 딕셔너리 키 오타\n\n**증상**: `KeyError: 'g4'`\n\n**원인**: 대소문자가 다르면 다른 키로 인식!\n\n**해결**:\n```python\n# 잘못된 코드\nfreq = notes['g4']  # 소문자 g\n\n# 올바른 코드\nfreq = notes['G4']  # 대문자 G (딕셔너리에 정의된 대로!)\n```\n\n---\n\n### 실수 2: 부저 초기화 안 함\n\n**증상**: 소리가 안 나거나 이상한 소리\n\n**원인**: `PWM` 설정을 안 했거나 핀 번호가 틀림\n\n**해결**:\n```python\n# 잘못된 코드\nbuzzer = Pin(20)  # PWM이 아닌 일반 Pin\n\n# 올바른 코드\nbuzzer = PWM(Pin(20))  # PWM으로 감싸야 해요!\n```\n\n---\n\n### 실수 3: 음 사이에 끊김 없음\n\n**증상**: 음이 뭉개져서 들림\n\n**원인**: 음과 음 사이 쉬는 시간이 없음\n\n**해결**:\n```python\n# 잘못된 코드\ndef play_tone(frequency, duration):\n    buzzer.freq(frequency)\n    buzzer.duty_u16(30000)\n    time.sleep(duration)\n    # 바로 다음 음으로 넘어감\n\n# 올바른 코드\ndef play_tone(frequency, duration):\n    buzzer.freq(frequency)\n    buzzer.duty_u16(30000)\n    time.sleep(duration)\n    buzzer.duty_u16(0)    # 소리 끄기\n    time.sleep(0.05)      # ← 음 사이 짧은 쉼 추가!\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **사실 확인**: '라(A4)'의 주파수는 몇 Hz인가요?\n\n2. **적용 질문**: \"도미솔\"을 연주하려면 악보 리스트를 어떻게 만들어야 할까요?\n\n3. **이유 질문**: 왜 `play_tone` 함수를 만들어서 사용하나요? 그냥 코드를 반복해서 쓰면 안 되나요?\n\n<details>\n<summary>정답 확인</summary>\n\n1. **440Hz**입니다. 참고로 A4(라)는 음악에서 기준음으로 사용해요!\n\n2. ```python\n   do_mi_sol = [\n       ('C4', 0.5),  # 도\n       ('E4', 0.5),  # 미\n       ('G4', 0.5)   # 솔\n   ]\n   ```\n\n3. 함수를 사용하면:\n   - **재사용**: 같은 코드를 여러 번 쓸 필요 없음\n   - **수정 용이**: 한 곳만 고치면 전체에 적용\n   - **가독성**: 코드가 깔끔해짐\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 비행기 연주하기 🛫\n\"비행기\" 동요를 연주해보세요!\n```\n미레도레 미미미 (날아라 비행기)\n```\n\n**힌트**: \n```python\nairplane = [\n    ('E4', 0.5), ('D4', 0.5), ('C4', 0.5), ('D4', 0.5),\n    ('E4', 0.5), ('E4', 0.5), ('E4', 1.0)\n]\n```\n\n---\n\n### 도전 2: 연주 속도 조절 ⏱️\nBPM(빠르기)을 조절하는 기능을 추가해보세요!\n\n**힌트**:\n```python\ndef play_melody(melody, speed=1.0):\n    for note_name, duration in melody:\n        freq = notes[note_name]\n        play_tone(freq, duration / speed)  # speed로 나누면 빨라짐\n```\n\n---\n\n### 도전 3: 버튼으로 노래 선택 ⭐\n버튼을 누를 때마다 다른 노래가 연주되게 만들어보세요!\n\n**힌트**:\n```python\nsongs = [school_bell, airplane, my_song]  # 노래 목록\ncurrent = 0  # 현재 노래 번호\n\n# 버튼 누르면\ncurrent = (current + 1) % len(songs)  # 다음 노래로\nplay_melody(songs[current])\n```\n\n---\n\n## 🔗 다음 장으로\n\n축하해요! 🎉 이번 장에서 배운 것들:\n\n- ✅ 음계와 주파수의 관계 (도=262Hz, 레=294Hz...)\n- ✅ 악보를 리스트 데이터로 변환하기\n- ✅ 함수를 만들어 코드 재사용하기\n- ✅ 피코로 \"학교종\" 연주 성공!\n\n**함수**는 프로그래밍에서 정말 중요한 개념이에요. 코드를 깔끔하게 정리하고, 재사용하고, 관리하기 쉽게 만들어주죠.\n\n다음 장에서는 **OLED 디스플레이**를 다뤄볼 거예요. 지금까지 소리와 빛으로 표현했다면, 이제는 **화면에 글자와 그림**을 그려봅시다! 📺",
      "tokens_used": 19794,
      "input_tokens": 13341,
      "output_tokens": 6453
    },
    {
      "success": true,
      "chapter_id": "chapter12",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter12.md",
      "content": "# 피아노 만들기 - 버튼으로 연주\n\n> **Part 4**: 소리로 표현하기 - 부저 활용\n\n---\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 여러 버튼 입력을 동시에 처리할 수 있다\n- [ ] 버튼별로 다른 음을 출력하는 프로그램을 작성할 수 있다\n- [ ] 버튼과 LED를 연동하여 시각적 피드백을 추가할 수 있다\n- [ ] 이전에 배운 내용들을 조합하여 복합 프로젝트를 완성할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n지금까지 우리는 버튼 하나 읽기, LED 하나 켜기, 부저로 소리 내기를 각각 배웠어요. 하지만 실제 전자제품은 **여러 입력을 동시에 처리**하잖아요? \n\nTV 리모컨을 생각해보세요. 버튼이 수십 개인데, 어떤 버튼을 눌러도 즉시 반응하죠. 오늘 만들 미니 피아노도 마찬가지예요. 4개의 버튼을 연결하고, 각 버튼에 '도, 레, 미, 파' 음을 할당하면 **손가락으로 직접 연주**할 수 있어요!\n\n이 프로젝트를 완성하면:\n- 🎹 직접 만든 악기로 간단한 멜로디 연주 가능\n- 💡 여러 입력을 효율적으로 처리하는 패턴 학습\n- 🔧 지금까지 배운 모든 것을 하나로 통합\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 여러 버튼 동시 처리\n\n1. **비유로 시작**: \"여러 버튼을 처리하는 건 마치 콜센터 상담원과 같아요. 여러 전화(버튼)가 올 수 있지만, 한 번에 하나씩 빠르게 확인하면 마치 동시에 처리하는 것처럼 느껴지죠.\"\n\n2. **정확한 정의**: \"피코는 매우 빠르게 동작하기 때문에, 여러 버튼을 순서대로 확인해도 사람이 느끼기엔 '동시'처럼 보입니다. 이걸 **폴링(Polling)** 방식이라고 해요.\"\n\n3. **예시로 확인**: \n```python\n# 버튼 4개를 순서대로 확인\nif 버튼1.value():\n    도 연주\nif 버튼2.value():\n    레 연주\n# ... 이게 1초에 수천 번 반복!\n```\n\n**쉽게 말하면**: 버튼마다 `if`문으로 체크하면, 피코가 알아서 빠르게 처리해줍니다.\n\n---\n\n### 개념 2: 딕셔너리로 버튼-음 연결\n\n1. **비유로 시작**: \"딕셔너리는 마치 전화번호부와 같아요. '이름 → 전화번호'처럼, '버튼 → 음' 을 연결해두면 편리하죠.\"\n\n2. **정확한 정의**: \"파이썬의 딕셔너리는 `{키: 값}` 형태로 데이터를 저장합니다. 버튼 객체를 키로, 음의 주파수를 값으로 저장하면 코드가 깔끔해져요.\"\n\n3. **예시로 확인**:\n```python\n# 버튼별 음 주파수 딕셔너리\nbutton_notes = {\n    button1: 262,  # 도\n    button2: 294,  # 레\n    button3: 330,  # 미\n    button4: 349,  # 파\n}\n```\n\n**쉽게 말하면**: 버튼과 음을 짝지어 놓으면, 어떤 버튼이든 해당 음을 쉽게 찾을 수 있어요.\n\n---\n\n### 개념 3: 음계와 주파수\n\n피아노 건반의 각 음은 고유한 **주파수(Hz)**를 가지고 있어요.\n\n```mermaid\nflowchart LR\n    A[\"🎵 도<br>262Hz\"] --> B[\"🎵 레<br>294Hz\"]\n    B --> C[\"🎵 미<br>330Hz\"]\n    C --> D[\"🎵 파<br>349Hz\"]\n    \n    style A fill:#ffcdd2,stroke:#c62828\n    style B fill:#fff9c4,stroke:#f9a825\n    style C fill:#c8e6c9,stroke:#2e7d32\n    style D fill:#bbdefb,stroke:#1565c0\n```\n\n| 음 | 주파수(Hz) | 설명 |\n|:--:|:--:|:--|\n| 도(C4) | 262 | 가온다 |\n| 레(D4) | 294 | |\n| 미(E4) | 330 | |\n| 파(F4) | 349 | |\n\n**쉽게 말하면**: 숫자가 클수록 높은 음이에요!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 버튼 4개 연결하기\n\n**목표**: 4개의 버튼을 피코에 연결하고 각각 읽기\n\n우선 하드웨어를 연결해볼게요.\n\n```mermaid\nflowchart TB\n    subgraph PICO[\"🔌 Pico + Grove Shield\"]\n        D16[\"D16 포트\"]\n        D18[\"D18 포트\"]\n        D20[\"D20 포트\"]\n        D21[\"D21 포트\"]\n    end\n    \n    subgraph BUTTONS[\"🔘 버튼들\"]\n        B1[\"버튼1 - 도\"]\n        B2[\"버튼2 - 레\"]\n        B3[\"버튼3 - 미\"]\n        B4[\"버튼4 - 파\"]\n    end\n    \n    D16 --> B1\n    D18 --> B2\n    D20 --> B3\n    D21 --> B4\n    \n    style PICO fill:#e3f2fd,stroke:#1976d2\n    style BUTTONS fill:#fff3e0,stroke:#f57c00\n```\n\n> 💡 **팁**: Grove 버튼이 4개 없다면, 2개로 시작해도 괜찮아요!\n\n**코드**:\n```python\n# === WHAT: 4개 버튼의 상태를 읽는 코드 ===\n# 각 버튼이 눌렸는지 확인해요\n\n# --- WHY: 피아노 건반처럼 사용하려면 ---\n# 여러 버튼을 동시에 감지할 수 있어야 해요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin  # 핀 제어 라이브러리\nimport time              # 시간 관련 기능\n\n# 버튼 4개를 각각 설정\nbtn_do = Pin(16, Pin.IN, Pin.PULL_DOWN)  # 도 버튼\nbtn_re = Pin(18, Pin.IN, Pin.PULL_DOWN)  # 레 버튼\nbtn_mi = Pin(20, Pin.IN, Pin.PULL_DOWN)  # 미 버튼\nbtn_fa = Pin(21, Pin.IN, Pin.PULL_DOWN)  # 파 버튼\n\nprint(\"버튼을 눌러보세요!\")\n\nwhile True:\n    # 각 버튼 상태 확인\n    if btn_do.value():\n        print(\"도!\")\n    if btn_re.value():\n        print(\"레!\")\n    if btn_mi.value():\n        print(\"미!\")\n    if btn_fa.value():\n        print(\"파!\")\n    \n    time.sleep(0.1)  # 0.1초마다 확인\n```\n\n**실행 결과**:\n```\n버튼을 눌러보세요!\n도!\n레!\n미!\n파!\n```\n\n**여기서 잠깐! 🤔**\n`if`문이 `elif`가 아니라 모두 `if`인 이유가 뭘까요? 두 버튼을 **동시에** 누를 수도 있기 때문이에요! `elif`를 쓰면 하나만 인식되거든요.\n\n---\n\n### Step 2: 버튼에 소리 연결하기\n\n**목표**: 각 버튼을 누르면 해당하는 음이 나오게 하기\n\n**코드**:\n```python\n# === WHAT: 버튼별로 다른 음 내기 ===\n# 버튼1=도, 버튼2=레, 버튼3=미, 버튼4=파\n\n# --- WHY: 미니 피아노의 핵심 기능! ---\n# 버튼과 음의 연결이 피아노를 만드는 거예요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin, PWM\nimport time\n\n# 버튼 설정\nbtn_do = Pin(16, Pin.IN, Pin.PULL_DOWN)\nbtn_re = Pin(18, Pin.IN, Pin.PULL_DOWN)\nbtn_mi = Pin(20, Pin.IN, Pin.PULL_DOWN)\nbtn_fa = Pin(21, Pin.IN, Pin.PULL_DOWN)\n\n# 부저 설정 (Grove 부저는 D22에 연결)\nbuzzer = PWM(Pin(22))\n\n# 음계 주파수 정의\nNOTE_DO = 262  # 도\nNOTE_RE = 294  # 레\nNOTE_MI = 330  # 미\nNOTE_FA = 349  # 파\n\ndef play_tone(freq):\n    \"\"\"주어진 주파수로 소리 내기\"\"\"\n    buzzer.freq(freq)\n    buzzer.duty_u16(32768)  # 50% 듀티 (소리 ON)\n\ndef stop_tone():\n    \"\"\"소리 멈추기\"\"\"\n    buzzer.duty_u16(0)  # 듀티 0 (소리 OFF)\n\nprint(\"🎹 미니 피아노 시작!\")\nprint(\"버튼을 눌러 연주하세요~\")\n\nwhile True:\n    sound_playing = False  # 소리가 나고 있는지 체크\n    \n    if btn_do.value():\n        play_tone(NOTE_DO)\n        sound_playing = True\n    elif btn_re.value():\n        play_tone(NOTE_RE)\n        sound_playing = True\n    elif btn_mi.value():\n        play_tone(NOTE_MI)\n        sound_playing = True\n    elif btn_fa.value():\n        play_tone(NOTE_FA)\n        sound_playing = True\n    \n    # 아무 버튼도 안 눌리면 소리 끄기\n    if not sound_playing:\n        stop_tone()\n    \n    time.sleep(0.01)  # 빠르게 체크 (반응성 향상)\n```\n\n**실행 결과**:\n```\n🎹 미니 피아노 시작!\n버튼을 눌러 연주하세요~\n(버튼을 누르면 해당 음이 들림!)\n```\n\n**여기서 잠깐! 🤔**\n여기서는 `elif`를 사용했어요. 부저가 1개라서 동시에 두 음을 낼 수 없거든요. 먼저 누른 버튼의 음이 우선이에요.\n\n---\n\n### Step 3: LED로 시각 효과 추가\n\n**목표**: 누른 버튼에 해당하는 LED도 함께 켜지게 하기\n\n```mermaid\nflowchart LR\n    subgraph INPUT[\"🔘 입력\"]\n        B[\"버튼 누름\"]\n    end\n    \n    subgraph PROCESS[\"⚙️ 처리\"]\n        C[\"피코가 감지\"]\n    end\n    \n    subgraph OUTPUT[\"📤 출력\"]\n        D[\"🔊 소리\"]\n        E[\"💡 LED\"]\n    end\n    \n    B --> C\n    C --> D\n    C --> E\n    \n    style INPUT fill:#e3f2fd,stroke:#1976d2\n    style PROCESS fill:#fff3e0,stroke:#f57c00\n    style OUTPUT fill:#e8f5e9,stroke:#388e3c\n```\n\n**코드**:\n```python\n# === WHAT: 소리 + LED 동시 출력 ===\n# 버튼 누르면 소리도 나고 LED도 켜져요\n\n# --- WHY: 실제 전자 피아노처럼! ---\n# 건반 누르면 불빛이 들어오는 것처럼요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin, PWM\nimport time\n\n# ===== 핀 설정 =====\n# 버튼들 (입력)\nbtn_do = Pin(16, Pin.IN, Pin.PULL_DOWN)\nbtn_re = Pin(18, Pin.IN, Pin.PULL_DOWN)\nbtn_mi = Pin(20, Pin.IN, Pin.PULL_DOWN)\nbtn_fa = Pin(21, Pin.IN, Pin.PULL_DOWN)\n\n# 부저 (출력)\nbuzzer = PWM(Pin(22))\n\n# LED (피코 내장 LED 사용)\nled = Pin(\"LED\", Pin.OUT)\n\n# ===== 음계 정의 =====\nNOTES = {\n    'do': 262,\n    're': 294,\n    'mi': 330,\n    'fa': 349\n}\n\n# ===== 함수 정의 =====\ndef play_note(note_name):\n    \"\"\"음 연주 + LED 켜기\"\"\"\n    freq = NOTES.get(note_name, 0)\n    if freq > 0:\n        buzzer.freq(freq)\n        buzzer.duty_u16(32768)\n        led.on()\n        print(f\"♪ {note_name}!\")\n\ndef stop_all():\n    \"\"\"모든 출력 끄기\"\"\"\n    buzzer.duty_u16(0)\n    led.off()\n\n# ===== 메인 루프 =====\nprint(\"🎹 LED 피아노 시작!\")\n\nwhile True:\n    pressed = False\n    \n    if btn_do.value():\n        play_note('do')\n        pressed = True\n    elif btn_re.value():\n        play_note('re')\n        pressed = True\n    elif btn_mi.value():\n        play_note('mi')\n        pressed = True\n    elif btn_fa.value():\n        play_note('fa')\n        pressed = True\n    \n    if not pressed:\n        stop_all()\n    \n    time.sleep(0.01)\n```\n\n**실행 결과**:\n```\n🎹 LED 피아노 시작!\n♪ do!\n♪ re!\n♪ mi!\n♪ fa!\n```\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 미니 피아노 - 완성 버전 ===\n# 4개 버튼으로 도레미파 연주 + LED 효과\n\nfrom machine import Pin, PWM\nimport time\n\n# ========== 설정 ==========\n# 버튼 (Grove 버튼들)\nbuttons = {\n    'do': Pin(16, Pin.IN, Pin.PULL_DOWN),\n    're': Pin(18, Pin.IN, Pin.PULL_DOWN),\n    'mi': Pin(20, Pin.IN, Pin.PULL_DOWN),\n    'fa': Pin(21, Pin.IN, Pin.PULL_DOWN)\n}\n\n# 부저\nbuzzer = PWM(Pin(22))\n\n# LED (내장 LED)\nled = Pin(\"LED\", Pin.OUT)\n\n# 음계 주파수\nNOTES = {\n    'do': 262,\n    're': 294,\n    'mi': 330,\n    'fa': 349\n}\n\n# ========== 함수 ==========\ndef play_note(note):\n    \"\"\"음 연주하기\"\"\"\n    buzzer.freq(NOTES[note])\n    buzzer.duty_u16(32768)\n    led.on()\n\ndef stop_sound():\n    \"\"\"소리 멈추기\"\"\"\n    buzzer.duty_u16(0)\n    led.off()\n\n# ========== 메인 ==========\nprint(\"=\" * 30)\nprint(\"🎹 미니 피아노\")\nprint(\"버튼을 눌러 연주하세요!\")\nprint(\"=\" * 30)\n\nwhile True:\n    played = False\n    \n    # 모든 버튼 확인\n    for note, button in buttons.items():\n        if button.value():\n            play_note(note)\n            played = True\n            break  # 한 음만 연주\n    \n    if not played:\n        stop_sound()\n    \n    time.sleep(0.01)\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 버튼이 계속 눌린 것처럼 인식됨\n\n**증상**: 버튼을 한 번만 눌렀는데 소리가 계속 남\n**원인**: `PULL_DOWN` 설정을 안 했거나, 배선이 잘못됨\n**해결**:\n```python\n# 잘못된 코드\nbtn = Pin(16, Pin.IN)  # PULL 설정 없음!\n\n# 올바른 코드\nbtn = Pin(16, Pin.IN, Pin.PULL_DOWN)  # PULL_DOWN 필수!\n```\n\n---\n\n### 실수 2: 부저에서 소리가 안 남\n\n**증상**: 코드는 실행되는데 부저가 조용함\n**원인**: `duty_u16` 값이 0이거나, 주파수 설정이 안 됨\n**해결**:\n```python\n# 잘못된 코드 - 순서가 잘못됨\nbuzzer.duty_u16(32768)\nbuzzer.freq(262)  # 주파수를 나중에 설정\n\n# 올바른 코드 - 주파수 먼저!\nbuzzer.freq(262)      # 1. 주파수 설정\nbuzzer.duty_u16(32768)  # 2. 소리 켜기\n```\n\n---\n\n### 실수 3: 딕셔너리 키 오류\n\n**증상**: `KeyError: 'Do'` 에러 발생\n**원인**: 대소문자가 다름 (Python은 대소문자 구분!)\n**해결**:\n```python\n# 잘못된 코드\nNOTES = {'do': 262}\nfreq = NOTES['Do']  # 'Do' ≠ 'do' 에러!\n\n# 올바른 코드\nNOTES = {'do': 262}\nfreq = NOTES['do']  # 정확히 같은 키 사용\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **사실 확인**: '도' 음의 주파수는 몇 Hz인가요?\n\n2. **적용 질문**: '솔' 음(392Hz)을 추가하려면 어떤 코드를 수정해야 할까요?\n\n3. **이유 질문**: 버튼 체크할 때 `elif` 대신 모두 `if`를 쓰면 어떤 문제가 생길까요?\n\n<details>\n<summary>정답 확인</summary>\n\n1. **262Hz**입니다.\n\n2. 두 곳을 수정해요:\n   - 버튼 추가: `'sol': Pin(XX, Pin.IN, Pin.PULL_DOWN)`\n   - 음 추가: `'sol': 392`\n\n3. 부저가 1개라서 마지막 `if`의 음만 나와요. 여러 버튼을 동시에 눌러도 '파'만 들릴 거예요.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 음역 확장하기 (⭐)\n5번째 버튼을 추가하고 '솔'(392Hz) 음을 연결해보세요.\n\n### 도전 2: 학교종 연주하기 (⭐⭐)\n\"학교종이 땡땡땡\" 멜로디를 자동 연주하는 코드를 작성해보세요.\n\n**힌트**: 음과 길이를 리스트로 저장하면 돼요!\n```python\n# 학교종 멜로디 힌트\nmelody = [\n    ('sol', 0.3), ('sol', 0.3), ('la', 0.3), ('la', 0.3),\n    ('sol', 0.3), ('sol', 0.3), ('mi', 0.6),\n    # ... 계속\n]\n```\n\n### 도전 3: 녹음 & 재생 기능 (⭐⭐⭐)\n누른 버튼 순서를 기억했다가 다시 재생하는 기능을 만들어보세요!\n- 녹음 시작/종료 버튼 추가\n- 리스트에 누른 음 저장\n- 재생 버튼으로 순서대로 연주\n\n---\n\n## 🔗 다음 장으로\n\n오늘 우리는 **버튼 + 부저 + LED**를 조합해서 미니 피아노를 완성했어요! 🎉\n\n**배운 것 정리**:\n- ✅ 여러 버튼을 `if`문으로 빠르게 체크\n- ✅ 딕셔너리로 버튼과 음을 연결\n- ✅ PWM으로 다양한 음 연주\n- ✅ 여러 출력 장치 동시 제어\n\n다음 장에서는 **OLED 디스플레이**를 배워요! 화면에 텍스트와 그래픽을 표시하면, 지금 어떤 음이 연주 중인지 눈으로 볼 수 있겠죠? 피아노에 디스플레이를 달면 더 멋진 악기가 될 거예요! 🎹✨",
      "tokens_used": 19699,
      "input_tokens": 13354,
      "output_tokens": 6345
    },
    {
      "success": true,
      "chapter_id": "chapter13",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter13.md",
      "content": "# 밝기 감지 - 조도 센서\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 아날로그 입력과 디지털 입력의 차이를 설명할 수 있다\n- [ ] ADC(아날로그-디지털 변환)의 개념을 이해할 수 있다\n- [ ] 조도 센서 값을 읽어 밝기를 측정할 수 있다\n- [ ] 밝기에 따라 LED를 자동으로 제어할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n스마트폰 화면을 보세요. 어두운 곳에서는 화면이 어두워지고, 밝은 곳에서는 밝아집니다. 이게 어떻게 가능할까요? 바로 **조도 센서**가 주변 밝기를 측정하기 때문이에요!\n\n버튼은 \"눌렀다/안 눌렀다\" 두 가지 상태만 구분합니다. 하지만 밝기는 어떨까요? \"아주 어둡다 → 조금 어둡다 → 보통 → 밝다 → 아주 밝다\"처럼 **연속적인 값**을 가집니다.\n\n이런 연속적인 값을 읽으려면 **아날로그 입력**이 필요합니다. 이번 장에서 아날로그 세계로 한 발짝 들어가 봅시다!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 디지털 vs 아날로그\n\n**비유로 시작**: 디지털은 **계단**, 아날로그는 **경사로**와 같아요.\n\n```mermaid\nflowchart LR\n    subgraph 디지털[\"🔢 디지털 (계단)\"]\n        D1[OFF<br>0] --> D2[ON<br>1]\n    end\n    subgraph 아날로그[\"📊 아날로그 (경사로)\"]\n        A1[0] --> A2[0.5] --> A3[1.0] --> A4[1.5] --> A5[2.0]\n    end\n    \n    style D1 fill:#ffcdd2,stroke:#c62828\n    style D2 fill:#c8e6c9,stroke:#2e7d32\n    style A1 fill:#e3f2fd,stroke:#1976d2\n    style A2 fill:#bbdefb,stroke:#1976d2\n    style A3 fill:#90caf9,stroke:#1976d2\n    style A4 fill:#64b5f6,stroke:#1976d2\n    style A5 fill:#42a5f5,stroke:#1976d2\n```\n\n**정확히 말하면**:\n- **디지털**: 0 또는 1, 두 가지 상태만 존재 (버튼, LED 켜기/끄기)\n- **아날로그**: 연속적인 값 (밝기, 온도, 소리 크기)\n\n**예시로 확인**:\n| 센서 | 신호 타입 | 값의 범위 |\n|------|----------|----------|\n| 버튼 | 디지털 | 0 또는 1 |\n| 조도 센서 | 아날로그 | 0 ~ 65535 |\n| 온도 센서 | 아날로그 | 다양한 값 |\n\n**쉽게 말하면**: 디지털은 \"예/아니오\", 아날로그는 \"얼마나?\"입니다.\n\n---\n\n### 개념 2: ADC (아날로그-디지털 변환)\n\n**비유로 시작**: ADC는 **통역사**와 같아요. 아날로그 세상의 언어를 컴퓨터가 이해하는 디지털 숫자로 번역해줍니다.\n\n```mermaid\nflowchart LR\n    A[🌡️ 아날로그 신호<br>연속적인 전압] --> B[🔄 ADC<br>변환기] --> C[💻 디지털 값<br>0~65535 숫자]\n    \n    style A fill:#fff3e0,stroke:#f57c00\n    style B fill:#e8f5e9,stroke:#388e3c\n    style C fill:#e3f2fd,stroke:#1976d2\n```\n\n**정확히 말하면**: \n- ADC = Analog to Digital Converter (아날로그-디지털 변환기)\n- 피코는 **16비트 ADC**를 가지고 있어요\n- 16비트 = 2^16 = **65,536단계** (0 ~ 65535)\n\n**예시로 확인**:\n- 조도 센서에 빛이 없으면 → 낮은 값 (예: 500)\n- 조도 센서에 빛이 많으면 → 높은 값 (예: 60000)\n\n**쉽게 말하면**: ADC는 연속적인 밝기를 0~65535 사이의 숫자로 바꿔주는 장치입니다.\n\n---\n\n### 개념 3: 조도 센서 (CdS / 포토레지스터)\n\n**비유로 시작**: 조도 센서는 **빛에 반응하는 가변 저항**이에요. 마치 빛이 많을수록 문이 활짝 열리는 것처럼, 빛이 많으면 저항이 낮아집니다.\n\n```mermaid\nflowchart TB\n    subgraph 어두울때[\"🌙 어두울 때\"]\n        D1[저항 높음] --> D2[전류 적음] --> D3[ADC 값 낮음]\n    end\n    subgraph 밝을때[\"☀️ 밝을 때\"]\n        B1[저항 낮음] --> B2[전류 많음] --> B3[ADC 값 높음]\n    end\n    \n    style D1 fill:#37474f,stroke:#263238,color:#fff\n    style D2 fill:#546e7a,stroke:#37474f,color:#fff\n    style D3 fill:#78909c,stroke:#546e7a\n    style B1 fill:#fff59d,stroke:#f9a825\n    style B2 fill:#ffee58,stroke:#fbc02d\n    style B3 fill:#ffeb3b,stroke:#f9a825\n```\n\n**쉽게 말하면**: 밝으면 값이 크고, 어두우면 값이 작습니다!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 조도 센서 연결하기\n\n**목표**: Grove 조도 센서를 피코에 연결합니다.\n\n```mermaid\nflowchart LR\n    subgraph Pico[\"🔧 Pico + Grove Shield\"]\n        A0[\"A0 포트<br>(아날로그)\"]\n    end\n    subgraph Sensor[\"💡 조도 센서\"]\n        CDS[\"Grove Light<br>Sensor\"]\n    end\n    \n    A0 <--\"Grove 케이블\"--> CDS\n    \n    style A0 fill:#e3f2fd,stroke:#1976d2\n    style CDS fill:#fff3e0,stroke:#f57c00\n```\n\n**연결 방법**:\n1. Grove 조도 센서를 찾으세요 (동그란 센서가 보여요)\n2. Grove 케이블로 센서와 Shield의 **A0 포트**를 연결하세요\n3. 케이블 방향은 상관없어요 (양쪽 다 같은 모양)\n\n> 💡 **Tip**: A0는 \"Analog 0\"의 약자예요. 아날로그 신호를 읽는 전용 포트입니다!\n\n---\n\n### Step 2: 기본 값 읽기\n\n**목표**: 조도 센서 값을 읽어서 출력합니다.\n\n**코드**:\n```python\n# === WHAT: 조도 센서 값 읽기 ===\n# 주변 밝기를 측정해서 숫자로 보여주는 코드예요\n\n# --- WHY: 왜 필요한지 ---\n# 밝기 값을 알아야 나중에 자동 조명을 만들 수 있어요\n\n# HOW: 어떻게 동작하는지\nfrom machine import ADC, Pin  # ADC: 아날로그 값을 읽는 도구\nimport time\n\n# 조도 센서 설정 (A0 포트 = GP26)\nlight_sensor = ADC(Pin(26))\n\n# 반복해서 밝기 측정\nwhile True:\n    light_value = light_sensor.read_u16()  # 16비트 값 읽기 (0~65535)\n    print(\"밝기:\", light_value)\n    time.sleep(0.5)  # 0.5초마다 측정\n```\n\n**실행 결과**:\n```\n밝기: 45230\n밝기: 45180\n밝기: 12500   ← 손으로 가렸을 때\n밝기: 58000   ← 손전등 비췄을 때\n밝기: 45300\n```\n\n**여기서 잠깐! 🤔**\n\n손으로 센서를 가려보세요! 값이 확 줄어드나요? 스마트폰 손전등을 비춰보세요! 값이 올라가나요?\n\n이렇게 **실시간으로 변하는 값**을 읽을 수 있다는 게 아날로그 입력의 매력입니다!\n\n---\n\n### Step 3: 밝기 단계로 표시하기\n\n**목표**: 숫자 대신 \"어둡다/보통/밝다\"로 표시합니다.\n\n**코드**:\n```python\n# === WHAT: 밝기를 단계로 표시 ===\n# 숫자 대신 이해하기 쉬운 말로 바꿔요\n\nfrom machine import ADC, Pin\nimport time\n\nlight_sensor = ADC(Pin(26))\n\nwhile True:\n    value = light_sensor.read_u16()\n    \n    # 값에 따라 상태 판단\n    if value < 20000:\n        status = \"🌙 어두움\"\n    elif value < 45000:\n        status = \"🌤️ 보통\"\n    else:\n        status = \"☀️ 밝음\"\n    \n    print(f\"밝기: {value} → {status}\")\n    time.sleep(0.5)\n```\n\n**실행 결과**:\n```\n밝기: 15230 → 🌙 어두움\n밝기: 35000 → 🌤️ 보통\n밝기: 52000 → ☀️ 밝음\n```\n\n**여기서 잠깐! 🤔**\n\n`20000`, `45000` 같은 기준값(임계값)은 환경마다 달라요! 여러분 교실에서 직접 값을 확인하고 조절해보세요.\n\n---\n\n### Step 4: 자동 야간등 만들기\n\n**목표**: 어두워지면 자동으로 LED가 켜지는 야간등을 만듭니다.\n\n```mermaid\nflowchart LR\n    A[💡 조도센서<br>밝기 측정] --> B{🤔 어둡나요?<br>값 < 20000}\n    B -->|\"예 🌙\"| C[💡 LED 켜기]\n    B -->|\"아니오 ☀️\"| D[💡 LED 끄기]\n    \n    style A fill:#fff3e0,stroke:#f57c00\n    style B fill:#e3f2fd,stroke:#1976d2\n    style C fill:#c8e6c9,stroke:#2e7d32\n    style D fill:#ffcdd2,stroke:#c62828\n```\n\n**코드**:\n```python\n# === WHAT: 자동 야간등 ===\n# 어두우면 LED가 켜지고, 밝으면 꺼져요\n\nfrom machine import ADC, Pin\nimport time\n\n# 센서와 LED 설정\nlight_sensor = ADC(Pin(26))  # A0 포트\nled = Pin(16, Pin.OUT)       # D16 포트에 LED 연결\n\nDARK_THRESHOLD = 20000  # 이 값보다 작으면 \"어둡다\"\n\nwhile True:\n    value = light_sensor.read_u16()\n    \n    if value < DARK_THRESHOLD:\n        led.on()\n        print(f\"🌙 어두움 ({value}) - LED 켜짐\")\n    else:\n        led.off()\n        print(f\"☀️ 밝음 ({value}) - LED 꺼짐\")\n    \n    time.sleep(0.3)\n```\n\n**실행 결과**:\n```\n☀️ 밝음 (45230) - LED 꺼짐\n🌙 어두움 (12500) - LED 켜짐  ← 손으로 가렸을 때\n🌙 어두움 (11800) - LED 켜짐\n☀️ 밝음 (48000) - LED 꺼짐  ← 손 뗐을 때\n```\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 자동 야간등 - 완성 코드 ===\n# 주변이 어두워지면 자동으로 LED가 켜집니다\n\nfrom machine import ADC, Pin\nimport time\n\n# ===== 설정 =====\nlight_sensor = ADC(Pin(26))  # 조도 센서 (A0)\nled = Pin(16, Pin.OUT)       # LED (D16)\n\nDARK_THRESHOLD = 20000  # 이 값보다 작으면 어둡다고 판단\n                         # ⬆️ 환경에 맞게 조절하세요!\n\n# ===== 메인 루프 =====\nprint(\"🌙 자동 야간등 시작!\")\nprint(\"센서를 손으로 가려보세요.\\n\")\n\nwhile True:\n    # 밝기 측정\n    value = light_sensor.read_u16()\n    \n    # 어두우면 LED 켜기\n    if value < DARK_THRESHOLD:\n        led.on()\n        status = \"🌙 어두움 - LED ON\"\n    else:\n        led.off()\n        status = \"☀️ 밝음 - LED OFF\"\n    \n    print(f\"밝기: {value:5d} | {status}\")\n    time.sleep(0.3)\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 잘못된 핀 번호 사용\n\n**증상**: \n```\nValueError: Pin(0) doesn't have ADC capabilities\n```\n\n**원인**: 아날로그 입력이 가능한 핀은 정해져 있어요.\n\n**해결**:\n```python\n# 잘못된 코드\nlight_sensor = ADC(Pin(0))  # GP0는 ADC 지원 안 함!\n\n# 올바른 코드\nlight_sensor = ADC(Pin(26))  # GP26 = A0 포트 ✅\n# 사용 가능: GP26(A0), GP27(A1), GP28(A2)\n```\n\n---\n\n### 실수 2: read_u16() 대신 value() 사용\n\n**증상**: \n```\nAttributeError: 'ADC' object has no attribute 'value'\n```\n\n**원인**: MicroPython에서는 `read_u16()` 메서드를 사용해요.\n\n**해결**:\n```python\n# 잘못된 코드\nvalue = light_sensor.value()  # Arduino 스타일\n\n# 올바른 코드\nvalue = light_sensor.read_u16()  # MicroPython 스타일 ✅\n```\n\n---\n\n### 실수 3: 임계값이 환경에 안 맞음\n\n**증상**: LED가 항상 켜져있거나 항상 꺼져있음\n\n**원인**: 교실/집의 밝기가 코드의 기준값과 다름\n\n**해결**:\n```python\n# 1단계: 먼저 현재 환경의 값 확인\nwhile True:\n    print(light_sensor.read_u16())  # 값 확인\n    time.sleep(0.5)\n\n# 2단계: 확인한 값을 기준으로 임계값 설정\n# 예: 평소 35000, 손으로 가리면 8000이라면\nDARK_THRESHOLD = 20000  # 중간값으로 설정\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **아날로그와 디지털의 가장 큰 차이점은 무엇인가요?**\n\n2. **피코의 ADC가 출력하는 값의 범위는 얼마인가요?**\n\n3. **조도 센서를 손으로 가리면 ADC 값은 어떻게 변하나요? 그 이유는?**\n\n<details>\n<summary>정답 확인</summary>\n\n1. **디지털**은 0과 1 두 가지 상태만 있고, **아날로그**는 연속적인 값을 가집니다.\n\n2. **0 ~ 65535** (16비트, 2^16 = 65536단계)\n\n3. **값이 작아집니다.** 이유: 빛이 줄어들면 센서의 저항이 높아지고, 전류가 적게 흘러 ADC 값이 낮아지기 때문입니다.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 밝기 막대 그래프 (쉬움)\nShell에 밝기를 막대 그래프로 표시해보세요!\n```\n밝기: ████████████████░░░░ (52000)\n밝기: ████░░░░░░░░░░░░░░░░ (15000)\n```\n\n> 💡 힌트: `value // 3300`으로 0~20 사이 값으로 변환!\n\n---\n\n### 도전 2: 3단계 자동 조명 (중간)\n밝기에 따라 LED 여러 개를 단계적으로 켜보세요.\n- 아주 어두움: LED 3개 모두 켜짐\n- 조금 어두움: LED 2개 켜짐\n- 밝음: LED 모두 꺼짐\n\n---\n\n### 도전 3: 스마트 무드등 ⭐ (어려움)\n조도 센서 + PWM을 결합해서, 어두워질수록 LED가 **서서히 밝아지는** 무드등을 만들어보세요!\n\n> 💡 힌트: PWM의 duty 값을 조도 센서 값에 반비례하게 설정!\n\n---\n\n## 🔗 다음 장으로\n\n이번 장에서 배운 것:\n- ✅ 아날로그 vs 디지털의 차이\n- ✅ ADC로 연속적인 값 읽기\n- ✅ 조도 센서로 밝기 측정\n- ✅ 자동 야간등 만들기\n\n다음 장에서는 **거리 측정 - 초음파 센서**를 배웁니다. 박쥐처럼 소리로 거리를 측정하는 원리를 알아보고, 물체가 가까이 오면 반응하는 시스템을 만들어볼 거예요! 🦇",
      "tokens_used": 18963,
      "input_tokens": 13340,
      "output_tokens": 5623
    },
    {
      "success": true,
      "chapter_id": "chapter14",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter14.md",
      "content": "# 자동 조명 만들기\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 센서 값을 기준으로 조건문을 작성할 수 있다\n- [ ] 임계값(threshold)의 개념을 이해하고 적절히 설정할 수 있다\n- [ ] 어두워지면 자동으로 켜지는 조명을 완성할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n집에 들어오면 알아서 켜지는 현관등, 해가 지면 자동으로 켜지는 가로등을 본 적 있나요? 이 똑똑한 조명들은 모두 **\"지금 어두운가?\"**를 판단해서 동작합니다.\n\n이번 장에서는 조도 센서로 밝기를 측정하고, **\"어느 정도 어두우면 켤까?\"**라는 기준(임계값)을 정해서 자동 조명을 만들어 봅니다. 센서 값을 읽는 것에서 한 발 더 나아가, **센서 값으로 판단하고 행동하는** 진짜 스마트 기기를 만드는 거예요!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 임계값(Threshold)\n\n1. **비유로 시작**: 임계값은 마치 **시험 합격선**과 같아요. 60점이 합격선이면, 60점 이상은 합격, 미만은 불합격이죠.\n\n2. **정확한 정의**: 임계값은 **어떤 동작을 실행할지 결정하는 기준값**입니다. 센서 값이 이 기준보다 크거나 작은지에 따라 다른 동작을 합니다.\n\n3. **예시로 확인**: 조도 센서 값이 20,000 미만이면 \"어둡다\"고 판단하고 LED를 켜요. 여기서 20,000이 임계값입니다.\n\n**쉽게 말하면**: \"이 값보다 작으면 어두운 거야!\"라고 정한 기준선이에요.\n\n---\n\n### 개념 2: 센서 값과 조건문의 결합\n\n센서로 측정한 값을 `if`문의 조건으로 사용하면, 피코가 스스로 판단해서 행동합니다.\n\n```mermaid\nflowchart LR\n    A[🔆 조도 센서] --> B{밝기 < 임계값?}\n    B -->|Yes 어둡다| C[💡 LED 켜기]\n    B -->|No 밝다| D[LED 끄기]\n    \n    style A fill:#fff3e0,stroke:#f57c00\n    style B fill:#e3f2fd,stroke:#1976d2\n    style C fill:#e8f5e9,stroke:#388e3c\n    style D fill:#ffebee,stroke:#c62828\n```\n\n**쉽게 말하면**: 센서가 눈이 되고, 조건문이 뇌가 되어 판단하는 거예요!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 현재 밝기 확인하기\n\n**목표**: 조도 센서로 지금 교실이 얼마나 밝은지 숫자로 확인해요.\n\n**준비**: Grove 조도 센서를 **A0 포트**에 연결하세요.\n\n**코드**:\n```python\n# === WHAT: 조도 센서 값 읽기 ===\n# 현재 환경의 밝기를 숫자로 확인합니다\n\n# --- WHY: 왜 필요한지 ---\n# 임계값을 정하려면 먼저 지금 환경이 어느 정도인지 알아야 해요\n\nfrom machine import ADC, Pin  # ADC: 아날로그 값을 읽는 기능\nimport time\n\nlight_sensor = ADC(Pin(26))  # A0 포트 = GPIO 26번\n\nwhile True:\n    light_value = light_sensor.read_u16()  # 0~65535 사이 값\n    print(\"밝기:\", light_value)\n    time.sleep(0.5)\n```\n\n**실행 결과**:\n```\n밝기: 45230\n밝기: 44890\n밝기: 12340  ← 센서를 손으로 가렸을 때\n밝기: 8920\n```\n\n**여기서 잠깐! 🤔**\n- 숫자가 **클수록 밝고**, **작을수록 어두워요**\n- 손으로 센서를 가려보면서 밝을 때와 어두울 때 값을 기억해두세요!\n\n---\n\n### Step 2: 임계값 정하기\n\n**목표**: 우리 환경에 맞는 적절한 임계값을 찾아요.\n\n밝을 때와 어두울 때 값의 **중간 정도**를 임계값으로 정하면 됩니다.\n\n| 상황 | 예시 값 |\n|------|---------|\n| 밝은 교실 | 40,000 ~ 50,000 |\n| 손으로 가림 | 5,000 ~ 15,000 |\n| **적절한 임계값** | **20,000 ~ 25,000** |\n\n💡 **Tip**: 환경마다 다르니까 직접 측정한 값을 기준으로 정하세요!\n\n---\n\n### Step 3: 자동 조명 완성하기\n\n**목표**: 어두워지면 자동으로 LED가 켜지는 프로그램을 만들어요.\n\n**준비**: Grove LED를 **D18 포트**에 연결하세요.\n\n**코드**:\n```python\n# === WHAT: 자동 조명 시스템 ===\n# 어두워지면 LED가 켜지고, 밝아지면 꺼집니다\n\n# --- WHY: 왜 필요한지 ---\n# 가로등, 현관등처럼 스스로 판단하는 조명을 만들어요\n\nfrom machine import ADC, Pin\nimport time\n\n# 센서와 LED 설정\nlight_sensor = ADC(Pin(26))  # A0 포트\nled = Pin(18, Pin.OUT)       # D18 포트\n\n# 임계값 설정 (직접 측정한 값으로 수정하세요!)\nTHRESHOLD = 20000\n\nwhile True:\n    light_value = light_sensor.read_u16()\n    \n    if light_value < THRESHOLD:  # 임계값보다 작으면 = 어둡다\n        led.on()\n        status = \"어두움 → LED 켜짐\"\n    else:                        # 임계값보다 크거나 같으면 = 밝다\n        led.off()\n        status = \"밝음 → LED 꺼짐\"\n    \n    print(f\"밝기: {light_value}, 상태: {status}\")\n    time.sleep(0.5)\n```\n\n**실행 결과**:\n```\n밝기: 45230, 상태: 밝음 → LED 꺼짐\n밝기: 44890, 상태: 밝음 → LED 꺼짐\n밝기: 12340, 상태: 어두움 → LED 켜짐  ← 손으로 가림\n밝기: 8920, 상태: 어두움 → LED 켜짐\n```\n\n**여기서 잠깐! 🤔**\n- `THRESHOLD = 20000` 이 한 줄만 바꾸면 민감도 조절 가능!\n- 값을 **낮추면** 아주 어두울 때만, **높이면** 조금만 어두워도 켜져요\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 스마트 자동 조명 시스템 ===\n# 조도 센서로 밝기를 측정하고 자동으로 LED를 제어합니다\n# Grove 조도 센서: A0 포트\n# Grove LED: D18 포트\n\nfrom machine import ADC, Pin\nimport time\n\n# 하드웨어 설정\nlight_sensor = ADC(Pin(26))  # A0 = GPIO 26\nled = Pin(18, Pin.OUT)       # D18 = GPIO 18\n\n# 임계값 설정 (환경에 맞게 조절하세요)\nTHRESHOLD = 20000\n\nprint(\"=== 자동 조명 시스템 시작 ===\")\nprint(f\"임계값: {THRESHOLD}\")\nprint(\"센서를 손으로 가려보세요!\")\nprint()\n\nwhile True:\n    # 밝기 측정\n    light_value = light_sensor.read_u16()\n    \n    # 판단 및 동작\n    if light_value < THRESHOLD:\n        led.on()\n        status = \"💡 LED ON\"\n    else:\n        led.off()\n        status = \"LED OFF\"\n    \n    # 상태 출력\n    print(f\"밝기: {light_value:5d} | {status}\")\n    time.sleep(0.5)\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 임계값 방향 헷갈림\n\n**증상**: 밝을 때 LED가 켜지고, 어두울 때 꺼짐\n\n**원인**: 조건문의 부등호 방향이 반대\n\n**해결**:\n```python\n# 잘못된 코드 (밝을 때 켜짐)\nif light_value > THRESHOLD:\n    led.on()\n\n# 올바른 코드 (어두울 때 켜짐)\nif light_value < THRESHOLD:\n    led.on()\n```\n\n💡 **기억하세요**: 조도 센서는 **밝으면 값이 크고**, **어두우면 값이 작아요**!\n\n---\n\n### 실수 2: 임계값이 너무 극단적\n\n**증상**: LED가 항상 켜져있거나 항상 꺼져있음\n\n**원인**: 임계값이 환경에 맞지 않음\n\n**해결**:\n```python\n# 잘못된 예: 임계값이 너무 낮음 (거의 안 켜짐)\nTHRESHOLD = 1000\n\n# 잘못된 예: 임계값이 너무 높음 (항상 켜짐)\nTHRESHOLD = 60000\n\n# 올바른 방법: 직접 측정한 값의 중간\n# 밝을 때 45000, 어두울 때 10000이면\nTHRESHOLD = 25000  # 중간값 사용\n```\n\n---\n\n### 실수 3: 센서 연결 포트 오류\n\n**증상**: `light_value`가 항상 0이거나 65535\n\n**원인**: 센서가 다른 포트에 연결됨\n\n**해결**:\n```python\n# A0 포트 = GPIO 26번\nlight_sensor = ADC(Pin(26))  # 반드시 26번!\n\n# A1 포트는 GPIO 27번\n# light_sensor = ADC(Pin(27))  # A1에 연결했다면\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **임계값을 30,000으로 설정했을 때, 센서 값이 25,000이면 LED는 어떻게 되나요?**\n\n2. **현재 교실에서 측정한 밝기가 밝을 때 50,000, 어두울 때 8,000이라면 적절한 임계값은 얼마일까요?**\n\n3. **왜 `<` (미만)을 사용해서 어두움을 판단하나요?**\n\n<details>\n<summary>정답 확인</summary>\n\n1. **LED가 켜집니다.** 25,000 < 30,000 이므로 어둡다고 판단합니다.\n\n2. **약 25,000 ~ 30,000 정도**가 적절합니다. 밝을 때와 어두울 때의 중간값이에요.\n\n3. 조도 센서는 **밝으면 값이 크고, 어두우면 값이 작기 때문**입니다. 값이 임계값보다 \"작으면\" 어두운 거예요.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 나만의 임계값 찾기 (쉬움)\n교실의 여러 상황(형광등 끔, 커튼 침, 손으로 가림)에서 센서 값을 측정하고, 가장 적절한 임계값을 찾아보세요.\n\n---\n\n### 도전 2: LED 깜빡임으로 경고하기 (중간)\n완전히 어두우면 LED가 계속 켜지고, 살짝 어두우면 깜빡이게 만들어보세요.\n\n**힌트**: 임계값을 2개 사용해요!\n```python\nDARK_THRESHOLD = 10000    # 완전 어두움\nDIM_THRESHOLD = 25000     # 살짝 어두움\n\nif light_value < DARK_THRESHOLD:\n    # 완전 어두움: LED 계속 켜기\nelif light_value < DIM_THRESHOLD:\n    # 살짝 어두움: LED 깜빡이기\nelse:\n    # 밝음: LED 끄기\n```\n\n---\n\n### 도전 3: 밝기에 따른 LED 밝기 조절 ⭐\nPWM을 사용해서 어두울수록 LED가 더 밝게, 밝을수록 LED가 어둡게 되는 조명을 만들어보세요.\n\n**힌트**: 센서 값을 PWM 값으로 변환해요!\n\n---\n\n## 🔗 다음 장으로\n\n이번 장에서는 **임계값**이라는 기준을 정해 센서 값으로 LED를 자동 제어하는 방법을 배웠어요. 이제 피코가 \"판단\"을 할 수 있게 되었습니다!\n\n다음 장에서는 **온습도 센서**를 사용해서 온도와 습도를 측정하는 방법을 배워요. 환경 모니터링 시스템의 기초가 됩니다!",
      "tokens_used": 17528,
      "input_tokens": 13341,
      "output_tokens": 4187
    },
    {
      "success": true,
      "chapter_id": "chapter15",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter15.md",
      "content": "# 온도계 만들기 - 온도 센서 활용\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 피코 내장 온도 센서의 동작 원리를 설명할 수 있다\n- [ ] ADC 값을 실제 섭씨 온도로 변환하는 공식을 적용할 수 있다\n- [ ] 측정한 온도를 포맷팅하여 보기 좋게 출력할 수 있다\n- [ ] 온도에 따라 LED나 부저로 경고하는 시스템을 만들 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n온도는 우리 생활에서 가장 많이 측정하는 물리량 중 하나예요. 날씨 앱, 에어컨 리모컨, 냉장고, 심지어 스마트폰까지 온도 센서가 들어있죠.\n\n**재미있는 사실**: 라즈베리파이 피코에는 온도 센서가 **이미 내장**되어 있어요! 추가 부품 없이도 바로 온도를 측정할 수 있답니다.\n\n이번 장에서는:\n- 센서가 보내는 \"날것의 숫자\"를 우리가 아는 **섭씨 온도로 변환**하는 방법\n- `27.5°C` 처럼 **예쁘게 출력**하는 기술\n- 온도가 너무 높으면 **자동으로 경고**하는 시스템\n\n을 만들어볼 거예요. 이 원리를 알면 나중에 어떤 센서든 \"읽고 → 변환하고 → 활용\"할 수 있게 됩니다!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 피코 내장 온도 센서\n\n1. **비유로 시작**: \"피코 내장 온도 센서는 마치 피코의 '체온계'와 같아요. 피코 칩 자체의 온도를 재는 거죠.\"\n\n2. **정확한 정의**: 피코의 RP2040 칩 내부에는 온도에 따라 전압이 변하는 센서가 있어요. 이 센서는 ADC 채널 4번에 연결되어 있습니다.\n\n3. **예시로 확인**: 방 온도가 25°C일 때, 피코 칩은 작동하면서 살짝 더 따뜻해져서 약 27~30°C 정도를 측정해요.\n\n**쉽게 말하면**: 피코 안에 이미 온도 센서가 들어있어서, 코드만 작성하면 바로 온도를 잴 수 있어요!\n\n---\n\n### 개념 2: ADC 값을 온도로 변환하기\n\n1. **비유로 시작**: \"ADC 값을 온도로 바꾸는 건, 외국 돈을 우리나라 돈으로 환전하는 것과 같아요. 환율 공식만 알면 돼요!\"\n\n2. **정확한 정의**: 피코 온도 센서는 다음 공식을 사용합니다:\n   ```\n   온도(°C) = 27 - (ADC전압 - 0.706) / 0.001721\n   ```\n   - `27`: 기준 온도\n   - `0.706V`: 27°C에서의 기준 전압\n   - `0.001721`: 1°C당 전압 변화량\n\n3. **예시로 확인**: ADC에서 읽은 전압이 0.700V라면\n   ```\n   온도 = 27 - (0.700 - 0.706) / 0.001721 = 27 - (-0.006) / 0.001721 ≈ 30.5°C\n   ```\n\n**쉽게 말하면**: 센서가 주는 숫자에 정해진 공식을 적용하면 섭씨 온도가 나와요!\n\n```mermaid\nflowchart LR\n    A[\"🔢 ADC 값<br/>(0~65535)\"] --> B[\"⚡ 전압 변환<br/>(0~3.3V)\"]\n    B --> C[\"🌡️ 온도 계산<br/>(공식 적용)\"]\n    C --> D[\"📺 출력<br/>(27.5°C)\"]\n    \n    style A fill:#e3f2fd,stroke:#1976d2\n    style B fill:#fff3e0,stroke:#f57c00\n    style C fill:#fce4ec,stroke:#c2185b\n    style D fill:#e8f5e9,stroke:#388e3c\n```\n\n---\n\n### 개념 3: 문자열 포맷팅\n\n1. **비유로 시작**: \"포맷팅은 마치 선물 포장과 같아요. 같은 내용물이라도 예쁘게 포장하면 받는 사람이 더 기뻐하죠!\"\n\n2. **정확한 정의**: 파이썬의 f-string을 사용하면 숫자를 원하는 형태로 출력할 수 있어요.\n   ```python\n   f\"{온도:.1f}°C\"  # 소수점 1자리까지 표시\n   ```\n\n3. **예시로 확인**:\n   ```python\n   temp = 27.456\n   print(f\"{temp:.1f}°C\")   # 출력: 27.5°C\n   print(f\"{temp:.2f}°C\")   # 출력: 27.46°C\n   ```\n\n**쉽게 말하면**: `.1f`는 \"소수점 아래 1자리만 보여줘\"라는 뜻이에요!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 내장 온도 센서 읽기\n\n**목표**: 피코 내장 온도 센서의 원시 값(raw value)을 읽어봅니다.\n\n**코드**:\n```python\n# === WHAT: 피코 내장 온도 센서 읽기 ===\n# 피코 칩 내부의 온도 센서에서 ADC 값을 읽어요\n\n# --- WHY: 왜 필요한지 ---\n# 모든 센서 활용의 첫 단계는 \"값 읽기\"예요\n# 먼저 센서가 어떤 값을 주는지 확인해야 해요\n\n# HOW: 어떻게 동작하는지\nfrom machine import ADC      # ADC(아날로그-디지털 변환) 라이브러리\nimport time                  # 시간 관련 기능\n\n# 내장 온도 센서는 ADC 채널 4번에 연결되어 있어요\ntemp_sensor = ADC(4)\n\n# 5번 측정해서 값 확인하기\nfor i in range(5):\n    raw_value = temp_sensor.read_u16()  # 16비트 값 읽기 (0~65535)\n    print(f\"측정 {i+1}: ADC 값 = {raw_value}\")\n    time.sleep(1)  # 1초 대기\n```\n\n**실행 결과**:\n```\n측정 1: ADC 값 = 39876\n측정 2: ADC 값 = 39912\n측정 3: ADC 값 = 39845\n측정 4: ADC 값 = 39889\n측정 5: ADC 값 = 39901\n```\n\n**여기서 잠깐! 🤔**\n- `read_u16()`은 0~65535 사이의 숫자를 반환해요\n- 이 숫자 자체는 온도가 아니에요! 변환이 필요합니다\n- 값이 조금씩 다른 건 정상이에요 (센서 노이즈)\n\n---\n\n### Step 2: ADC 값을 온도로 변환하기\n\n**목표**: 공식을 적용해서 실제 섭씨 온도를 계산합니다.\n\n**코드**:\n```python\n# === WHAT: ADC 값을 섭씨 온도로 변환하기 ===\n# 센서가 준 숫자를 우리가 아는 온도로 바꿔요\n\n# --- WHY: 왜 필요한지 ---\n# 39876 같은 숫자는 의미가 없어요\n# \"27.5°C\"처럼 이해할 수 있는 값이 필요해요\n\n# HOW: 어떻게 동작하는지\nfrom machine import ADC\nimport time\n\ntemp_sensor = ADC(4)\n\ndef read_temperature():\n    \"\"\"내장 온도 센서에서 섭씨 온도를 읽는 함수\"\"\"\n    # 1단계: ADC 원시 값 읽기\n    raw_value = temp_sensor.read_u16()\n    \n    # 2단계: 전압으로 변환 (3.3V 기준)\n    voltage = raw_value * 3.3 / 65535\n    \n    # 3단계: 온도로 변환 (피코 공식)\n    temperature = 27 - (voltage - 0.706) / 0.001721\n    \n    return temperature\n\n# 5번 측정\nfor i in range(5):\n    temp = read_temperature()\n    print(f\"측정 {i+1}: {temp}°C\")\n    time.sleep(1)\n```\n\n**실행 결과**:\n```\n측정 1: 28.234567890123456°C\n측정 2: 27.987654321098765°C\n측정 3: 28.456789012345678°C\n측정 4: 28.123456789012345°C\n측정 5: 28.345678901234567°C\n```\n\n**여기서 잠깐! 🤔**\n- 소수점이 너무 길어요! 다음 단계에서 깔끔하게 정리할 거예요\n- 피코 칩 온도라서 실제 방 온도보다 2~5°C 정도 높게 나와요\n\n---\n\n### Step 3: 예쁘게 출력하기\n\n**목표**: f-string 포맷팅으로 깔끔하게 온도를 표시합니다.\n\n**코드**:\n```python\n# === WHAT: 온도를 예쁘게 출력하기 ===\n# 소수점 1자리로 깔끔하게 표시해요\n\n# --- WHY: 왜 필요한지 ---\n# \"28.234567890123456°C\"보다 \"28.2°C\"가 훨씬 읽기 좋아요!\n\n# HOW: 어떻게 동작하는지\nfrom machine import ADC\nimport time\n\ntemp_sensor = ADC(4)\n\ndef read_temperature():\n    \"\"\"섭씨 온도를 반환하는 함수\"\"\"\n    raw_value = temp_sensor.read_u16()\n    voltage = raw_value * 3.3 / 65535\n    temperature = 27 - (voltage - 0.706) / 0.001721\n    return temperature\n\nprint(\"🌡️ 온도 모니터링 시작!\")\nprint(\"-\" * 25)\n\nfor i in range(5):\n    temp = read_temperature()\n    \n    # f-string으로 소수점 1자리까지만 표시\n    print(f\"  현재 온도: {temp:.1f}°C\")\n    time.sleep(1)\n\nprint(\"-\" * 25)\nprint(\"✅ 측정 완료!\")\n```\n\n**실행 결과**:\n```\n🌡️ 온도 모니터링 시작!\n-------------------------\n  현재 온도: 28.2°C\n  현재 온도: 28.0°C\n  현재 온도: 28.5°C\n  현재 온도: 28.1°C\n  현재 온도: 28.3°C\n-------------------------\n✅ 측정 완료!\n```\n\n**여기서 잠깐! 🤔**\n- `:.1f` = 소수점 아래 1자리 (float)\n- `:.2f` = 소수점 아래 2자리\n- `:.0f` = 정수로 표시 (소수점 없음)\n\n---\n\n### Step 4: 온도 경보기 만들기\n\n**목표**: 온도가 일정 기준을 넘으면 경고를 출력합니다.\n\n**코드**:\n```python\n# === WHAT: 온도 경보 시스템 ===\n# 온도가 너무 높으면 경고해요!\n\n# --- WHY: 왜 필요한지 ---\n# 서버실, 온실, 냉장고 등에서 온도 이상을 감지하는 게 중요해요\n\n# HOW: 어떻게 동작하는지\nfrom machine import ADC, Pin\nimport time\n\ntemp_sensor = ADC(4)\nled = Pin(\"LED\", Pin.OUT)  # 내장 LED\n\n# 경고 기준 온도 설정\nWARNING_TEMP = 30.0  # 30°C 이상이면 경고\n\ndef read_temperature():\n    \"\"\"섭씨 온도를 반환\"\"\"\n    raw_value = temp_sensor.read_u16()\n    voltage = raw_value * 3.3 / 65535\n    return 27 - (voltage - 0.706) / 0.001721\n\ndef check_temperature(temp):\n    \"\"\"온도 상태를 확인하고 경고 여부 반환\"\"\"\n    if temp >= WARNING_TEMP:\n        return \"🔴 경고! 온도 높음!\"\n    elif temp >= WARNING_TEMP - 3:\n        return \"🟡 주의: 온도 상승 중\"\n    else:\n        return \"🟢 정상\"\n\nprint(\"=\" * 30)\nprint(\"   🌡️ 온도 경보 시스템\")\nprint(f\"   경고 기준: {WARNING_TEMP}°C\")\nprint(\"=\" * 30)\n\nwhile True:\n    temp = read_temperature()\n    status = check_temperature(temp)\n    \n    print(f\"온도: {temp:.1f}°C  {status}\")\n    \n    # 경고 상태면 LED 깜빡임\n    if temp >= WARNING_TEMP:\n        led.on()\n        time.sleep(0.2)\n        led.off()\n        time.sleep(0.3)\n    else:\n        led.off()\n        time.sleep(1)\n```\n\n**실행 결과**:\n```\n==============================\n   🌡️ 온도 경보 시스템\n   경고 기준: 30.0°C\n==============================\n온도: 28.2°C  🟢 정상\n온도: 28.5°C  🟢 정상\n온도: 29.1°C  🟡 주의: 온도 상승 중\n온도: 30.2°C  🔴 경고! 온도 높음!\n온도: 30.5°C  🔴 경고! 온도 높음!\n```\n\n💡 **팁**: 손가락으로 피코 칩을 살짝 감싸면 체온으로 온도가 올라가요!\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 온도 경보 시스템 - 완성 코드 ===\n# 피코 내장 온도 센서로 실시간 모니터링 + LED 경고\n\nfrom machine import ADC, Pin\nimport time\n\n# === 하드웨어 설정 ===\ntemp_sensor = ADC(4)       # 내장 온도 센서 (채널 4)\nled = Pin(\"LED\", Pin.OUT)  # 내장 LED\n\n# === 설정 값 ===\nWARNING_TEMP = 30.0  # 경고 온도 (°C)\nINTERVAL = 1         # 측정 간격 (초)\n\n# === 함수 정의 ===\ndef read_temperature():\n    \"\"\"내장 온도 센서에서 섭씨 온도를 읽어 반환\"\"\"\n    raw = temp_sensor.read_u16()          # ADC 값 읽기\n    voltage = raw * 3.3 / 65535           # 전압 변환\n    temp = 27 - (voltage - 0.706) / 0.001721  # 온도 변환\n    return temp\n\ndef get_status(temp):\n    \"\"\"온도에 따른 상태 문자열 반환\"\"\"\n    if temp >= WARNING_TEMP:\n        return \"🔴 경고!\"\n    elif temp >= WARNING_TEMP - 3:\n        return \"🟡 주의\"\n    else:\n        return \"🟢 정상\"\n\n# === 메인 프로그램 ===\nprint(\"🌡️ 온도 모니터링 시작\")\nprint(f\"경고 기준: {WARNING_TEMP}°C\")\nprint(\"-\" * 30)\n\nwhile True:\n    temp = read_temperature()\n    status = get_status(temp)\n    \n    print(f\"현재 온도: {temp:.1f}°C  [{status}]\")\n    \n    # 경고 시 LED 깜빡임\n    if temp >= WARNING_TEMP:\n        led.toggle()\n        time.sleep(0.3)\n    else:\n        led.off()\n        time.sleep(INTERVAL)\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: ADC 값을 바로 온도로 착각\n\n**증상**: \"온도가 39000도래요?!\"\n\n**원인**: ADC 원시 값(0~65535)을 변환 없이 출력\n\n**해결**:\n```python\n# ❌ 잘못된 코드\ntemp = temp_sensor.read_u16()\nprint(f\"온도: {temp}°C\")  # 39876°C?!\n\n# ✅ 올바른 코드\nraw = temp_sensor.read_u16()\nvoltage = raw * 3.3 / 65535\ntemp = 27 - (voltage - 0.706) / 0.001721\nprint(f\"온도: {temp:.1f}°C\")  # 28.2°C\n```\n\n---\n\n### 실수 2: 포맷팅 문법 오류\n\n**증상**: `SyntaxError` 또는 이상한 출력\n\n**원인**: f-string 문법 실수\n\n**해결**:\n```python\ntemp = 28.5\n\n# ❌ 잘못된 코드들\nprint(f\"{temp.1f}°C\")    # 점(.) 위치 오류\nprint(f\"{temp:1f}°C\")    # 점(.) 누락\nprint(\"{temp:.1f}°C\")    # f 누락\n\n# ✅ 올바른 코드\nprint(f\"{temp:.1f}°C\")   # 콜론(:) 다음에 .1f\n```\n\n---\n\n### 실수 3: 실제 방 온도와 다르다고 당황\n\n**증상**: \"실제 온도는 25도인데 30도가 나와요\"\n\n**원인**: 피코 **칩 온도**를 측정하는 것이지, 공기 온도가 아님\n\n**해결**:\n```python\n# 💡 이해하기\n# - 내장 센서 = 피코 칩의 온도 (작동 시 발열)\n# - 보통 실제 기온보다 3~8°C 높음\n# - 정확한 실내 온도 측정에는 외부 센서(DHT11) 사용\n\n# 참고용 보정 (대략적)\nOFFSET = -5  # 실험으로 결정\nadjusted_temp = read_temperature() + OFFSET\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **사실 확인**: 피코 내장 온도 센서는 ADC 몇 번 채널에 연결되어 있나요?\n\n2. **적용 질문**: 온도를 소수점 2자리까지 표시하려면 포맷 코드를 어떻게 써야 하나요?\n\n3. **이유 질문**: 내장 온도 센서가 측정하는 온도가 실제 방 온도보다 높은 이유는 무엇인가요?\n\n<details>\n<summary>정답 확인</summary>\n\n1. **ADC 채널 4번**에 연결되어 있습니다. `ADC(4)`로 접근해요.\n\n2. `f\"{temp:.2f}°C\"` - 콜론 뒤에 `.2f`를 쓰면 소수점 아래 2자리까지 표시됩니다.\n\n3. 내장 센서는 **피코 칩 자체의 온도**를 측정하기 때문이에요. 피코가 작동하면서 발열이 생겨서 주변 공기보다 몇 도 더 따뜻해집니다.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 화씨 온도 추가 (쉬움)\n섭씨와 화씨를 함께 출력해보세요.\n```\n💡 힌트: 화씨 = 섭씨 × 9/5 + 32\n예: 현재 온도: 28.5°C / 83.3°F\n```\n\n### 도전 2: 최고/최저 온도 기록 (중간)\n프로그램 실행 동안 최고 온도와 최저 온도를 기록하고 표시해보세요.\n```\n💡 힌트: max_temp, min_temp 변수를 만들어서 비교\n예: 최고: 32.1°C | 최저: 27.8°C | 현재: 29.5°C\n```\n\n### 도전 3: Grove 부저로 경고음 추가 ⭐\n온도가 경고 수준을 넘으면 LED 뿐만 아니라 부저로 \"삐삐\" 경고음을 내보세요.\n```\n💡 힌트: \n- Grove 부저를 D20에 연결\n- PWM으로 소리 내기 (13장 참고)\n```\n\n---\n\n## 🔗 다음 장으로\n\n이번 장에서 배운 것:\n- ✅ 피코 내장 온도 센서 사용법\n- ✅ ADC 값 → 전압 → 온도 변환 공식\n- ✅ f-string으로 예쁘게 출력하기\n- ✅ 조건문으로 온도 경보 시스템 만들기\n\n**다음 장 예고**: 📏 **초음파로 거리 측정하기**\n\n온도 다음은 **거리**예요! 초음파 센서는 박쥐처럼 소리를 쏘고 돌아오는 시간으로 거리를 측정합니다. 자동차 후방 감지 센서, 로봇 청소기가 바로 이 원리를 사용해요. 다음 장에서 만나요! 🦇",
      "tokens_used": 19953,
      "input_tokens": 13339,
      "output_tokens": 6614
    },
    {
      "success": true,
      "chapter_id": "chapter16",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter16.md",
      "content": "# 프로젝트 기획 - 아이디어 구체화\n\n**Part 6**: 나만의 스마트 기기 - 통합 프로젝트\n\n---\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 나만의 프로젝트 아이디어를 선정하고 정리할 수 있다\n- [ ] 필요한 부품과 기능을 정리한 기획서를 작성할 수 있다\n- [ ] 단계별 개발 계획을 수립할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n지금까지 우리는 LED, 버튼, 센서, OLED, WiFi까지 정말 많은 것을 배웠어요. 하지만 이 모든 것은 **누군가 정해준 예제**를 따라한 것이었죠.\n\n이제는 다릅니다! 🚀\n\n**\"내가 원하는 것을 만든다\"** - 이것이 진짜 메이커의 시작이에요.\n\n세상의 모든 멋진 제품들은 누군가의 **\"이런 거 있으면 좋겠다\"**라는 생각에서 시작했어요. 여러분도 지금부터 그 첫 걸음을 떼는 거예요!\n\n좋은 기획 없이 바로 코딩을 시작하면? 중간에 방향을 잃고 헤매게 됩니다. 오늘 배우는 기획 방법은 앞으로 어떤 프로젝트를 하든 도움이 될 거예요.\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 프로젝트 기획이란?\n\n1. **비유로 시작**: \"프로젝트 기획은 마치 여행 계획과 같아요. 어디로(목표), 무엇을 타고(도구), 어떤 경로로(단계) 갈지 미리 정하는 거죠.\"\n\n2. **정확한 정의**: \"정확히 말하면, 만들고 싶은 것을 구체적으로 정의하고, 필요한 것들을 정리하고, 실행 순서를 계획하는 과정입니다.\"\n\n3. **예시로 확인**: \"예를 들어, '스마트 알람시계'를 만든다면 → 어떤 센서가 필요한지, 어떤 기능이 핵심인지, 며칠에 걸쳐 무엇을 만들지 정리하는 거예요.\"\n\n**쉽게 말하면**: 기획 = 무엇을 + 왜 + 어떻게 만들지 정리하는 것\n\n---\n\n### 개념 2: 좋은 프로젝트의 조건\n\n```mermaid\nflowchart TB\n    A[🎯 좋은 프로젝트] --> B[💡 실용적]\n    A --> C[⚡ 실현 가능]\n    A --> D[🌟 재미있음]\n    \n    B --> B1[\"실제로 쓸 수 있나?\"]\n    C --> C1[\"내 실력으로 만들 수 있나?\"]\n    D --> D1[\"만드는 과정이 즐거운가?\"]\n    \n    style A fill:#fff9c4,stroke:#f9a825\n    style B fill:#e3f2fd,stroke:#1976d2\n    style C fill:#e8f5e9,stroke:#388e3c\n    style D fill:#fce4ec,stroke:#c2185b\n```\n\n세 가지 조건을 모두 만족하면 최고의 프로젝트가 됩니다!\n\n**쉽게 말하면**: 쓸모있고 + 만들 수 있고 + 재미있어야 좋은 프로젝트!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 아이디어 브레인스토밍\n\n**목표**: 다양한 아이디어를 자유롭게 떠올리기\n\n**아이디어 예시 모음** 📋\n\n| 아이디어 | 핵심 기능 | 필요 부품 |\n|----------|----------|-----------|\n| 스마트 알람시계 | 시간 표시 + 알람 + 날씨 | OLED, 부저, WiFi |\n| 식물 물주기 알림기 | 토양 습도 측정 + 알림 | 토양센서, LED, 부저 |\n| 공부 집중 타이머 | 뽀모도로 타이머 + 휴식 알림 | OLED, 버튼, 부저 |\n| 방문자 알림기 | 움직임 감지 + 알림 | 초음파센서, LED, 부저 |\n| 스마트 무드등 | 밝기 자동 조절 + 색상 변경 | 조도센서, RGB LED |\n| 온습도 모니터 | 환경 측정 + 경고 | DHT11, OLED, LED |\n\n**여기서 잠깐! 🤔**\n\n아이디어가 떠오르지 않나요? 이 질문들에 답해보세요:\n- \"아침에 일어날 때 불편한 점은?\"\n- \"공부할 때 있으면 좋겠는 것은?\"\n- \"우리 집에서 자동화되면 좋겠는 것은?\"\n\n---\n\n### Step 2: 아이디어 평가하기\n\n**목표**: 여러 아이디어 중 하나를 선택하기\n\n아이디어가 몇 개 나왔다면, 아래 기준으로 점수를 매겨보세요 (1~5점):\n\n| 평가 기준 | 아이디어 A | 아이디어 B | 아이디어 C |\n|----------|-----------|-----------|-----------|\n| 실용성 (쓸모있나?) | ? | ? | ? |\n| 실현 가능성 (만들 수 있나?) | ? | ? | ? |\n| 흥미도 (재미있나?) | ? | ? | ? |\n| 부품 보유 여부 | ? | ? | ? |\n| **총점** | ? | ? | ? |\n\n가장 점수가 높은 아이디어를 선택하세요!\n\n**여기서 잠깐! 🤔**\n\n\"너무 쉬운 것 같은데...\" 걱정되나요? \n**괜찮아요!** 처음엔 작게 시작하고, 나중에 기능을 추가하면 됩니다.\n\n---\n\n### Step 3: 기획서 작성하기\n\n**목표**: 선택한 아이디어를 구체적인 기획서로 정리하기\n\n아래 템플릿을 채워보세요:\n\n---\n\n## 📄 프로젝트 기획서 템플릿\n\n### 1️⃣ 기본 정보\n- **프로젝트명**: \n- **만드는 사람**: \n- **예상 제작 기간**: 약 2시간 (다음 2차시)\n\n### 2️⃣ 프로젝트 소개\n- **한 줄 설명**: (이 기기는 무엇인가요?)\n- **해결하려는 문제**: (어떤 불편함을 해결하나요?)\n- **사용 대상**: (누가 사용하나요?)\n\n### 3️⃣ 핵심 기능 (3개 이내)\n| 기능 | 설명 | 우선순위 |\n|-----|------|---------|\n| 기능 1 | | ⭐⭐⭐ 필수 |\n| 기능 2 | | ⭐⭐ 중요 |\n| 기능 3 | | ⭐ 있으면 좋음 |\n\n### 4️⃣ 필요한 부품\n| 부품 | 용도 | 연결 포트 |\n|-----|------|----------|\n| | | |\n| | | |\n| | | |\n\n### 5️⃣ 개발 단계 (2시간 기준)\n| 단계 | 할 일 | 예상 시간 |\n|-----|------|----------|\n| 1단계 | 하드웨어 연결 | 20분 |\n| 2단계 | 기본 기능 구현 | 40분 |\n| 3단계 | 기능 통합 | 30분 |\n| 4단계 | 테스트 및 개선 | 20분 |\n| 5단계 | 발표 준비 | 10분 |\n\n### 6️⃣ 예상 결과물\n- **작동 시나리오**: (사용자가 어떻게 사용하나요?)\n- **성공 기준**: (뭐가 되면 성공인가요?)\n\n---\n\n## 📝 기획서 예시: 스마트 알람시계\n\n실제로 기획서가 어떻게 채워지는지 볼까요?\n\n### 1️⃣ 기본 정보\n- **프로젝트명**: 똑똑한 아침 알람시계\n- **만드는 사람**: 김피코\n- **예상 제작 기간**: 약 2시간\n\n### 2️⃣ 프로젝트 소개\n- **한 줄 설명**: 인터넷에서 시간을 받아와 알람을 울리고 날씨를 보여주는 시계\n- **해결하려는 문제**: 아침에 일어날 때 오늘 날씨를 바로 확인하고 싶다\n- **사용 대상**: 나 (책상 위에 두고 사용)\n\n### 3️⃣ 핵심 기능\n| 기능 | 설명 | 우선순위 |\n|-----|------|---------|\n| 시계 표시 | OLED에 현재 시간 표시 | ⭐⭐⭐ 필수 |\n| 알람 | 설정 시간에 부저로 알림 | ⭐⭐ 중요 |\n| 날씨 표시 | 현재 날씨 정보 표시 | ⭐ 있으면 좋음 |\n\n### 4️⃣ 필요한 부품\n| 부품 | 용도 | 연결 포트 |\n|-----|------|----------|\n| OLED | 시간/날씨 표시 | I2C |\n| 부저 | 알람 소리 | D20 |\n| 버튼 | 알람 끄기 | D18 |\n\n### 5️⃣ 개발 단계\n| 단계 | 할 일 | 예상 시간 |\n|-----|------|----------|\n| 1단계 | OLED 연결 및 시간 표시 | 20분 |\n| 2단계 | NTP 시간 동기화 | 20분 |\n| 3단계 | 알람 기능 추가 | 25분 |\n| 4단계 | 버튼으로 알람 끄기 | 20분 |\n| 5단계 | 테스트 및 발표 준비 | 15분 |\n\n### 6️⃣ 예상 결과물\n- **작동 시나리오**: 전원 켜면 → WiFi 연결 → 시간 표시 → 설정 시간에 부저 울림 → 버튼 누르면 알람 꺼짐\n- **성공 기준**: 정확한 시간이 표시되고, 알람이 제 시간에 울리면 성공!\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 너무 큰 목표 설정\n**증상**: \"AI 음성인식 스마트홈 시스템을 만들 거예요!\"\n\n**원인**: 처음이라 현실적인 범위를 가늠하기 어려움\n\n**해결**: \n```\n❌ 잘못된 목표: \"모든 기능이 다 되는 완벽한 시스템\"\n\n✅ 올바른 목표: \"일단 LED 하나 켜는 것부터!\"\n```\n\n**Tip**: 핵심 기능 1개만 확실히 되게 만들고, 나머지는 \"추가 기능\"으로!\n\n---\n\n### 실수 2: 기획 없이 바로 코딩 시작\n**증상**: 코딩하다 중간에 \"어... 이제 뭐하지?\"\n\n**원인**: 전체 그림 없이 시작함\n\n**해결**:\n```\n❌ 잘못된 순서: 코딩 → 막힘 → 고민 → 다시 시작\n\n✅ 올바른 순서: 기획 → 설계 → 코딩 → 완성\n```\n\n---\n\n### 실수 3: 없는 부품으로 기획\n**증상**: \"초음파 센서로 할 거예요!\" (근데 우리 키트에 없음)\n\n**원인**: 가지고 있는 부품을 확인하지 않음\n\n**해결**: 기획 전에 **부품 목록을 먼저 확인**하세요!\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **사실 확인**: 좋은 프로젝트의 세 가지 조건은 무엇인가요?\n\n2. **적용 질문**: 여러분의 프로젝트는 어떤 문제를 해결하나요?\n\n3. **이유 질문**: 왜 기획을 먼저 하고 코딩을 나중에 하는 게 좋을까요?\n\n<details>\n<summary>정답 확인</summary>\n\n1. 실용적(쓸모있음) + 실현 가능(만들 수 있음) + 재미있음\n\n2. (여러분의 답을 적어보세요!)\n\n3. 전체 방향을 먼저 정해야 중간에 헤매지 않고, 필요한 것을 미리 준비할 수 있기 때문입니다. 집을 지을 때 설계도 없이 바로 벽돌을 쌓지 않는 것과 같아요!\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 기획서 완성하기 (필수!)\n오늘 수업 시간 안에 **기획서를 완성**하세요. 빈칸 없이 모두 채워야 합니다!\n\n### 도전 2: 동료 피드백 받기\n옆 친구와 기획서를 교환하고, 아래 질문에 답해주세요:\n- 이 프로젝트가 뭘 하는지 이해가 되나요?\n- 2시간 안에 만들 수 있을 것 같나요?\n- 더 좋은 아이디어가 있나요?\n\n### 도전 3: 스케치 그리기 ⭐\n완성된 프로젝트가 어떻게 생겼을지 간단히 그림으로 그려보세요. 부품 배치, 버튼 위치 등을 표시하면 더 좋아요!\n\n---\n\n## 📋 오늘의 체크리스트\n\n다음 시간 전까지 꼭 완료하세요:\n\n- [ ] 프로젝트 아이디어 선정 완료\n- [ ] 기획서 템플릿 모든 항목 작성 완료\n- [ ] 필요한 부품 목록 확인 완료\n- [ ] 친구에게 기획서 피드백 받기 (선택)\n\n---\n\n## 🔗 다음 장으로\n\n오늘은 **무엇을 만들지** 계획을 세웠어요!\n\n여러분의 기획서가 완성되었다면, 다음 시간부터는 진짜 **만들기**가 시작됩니다! 🔧\n\n```mermaid\nflowchart LR\n    A[📋 오늘: 기획] --> B[⚙️ 다음: 제작] --> C[🎤 마지막: 발표]\n    \n    style A fill:#fff9c4,stroke:#f9a825\n    style B fill:#e3f2fd,stroke:#1976d2\n    style C fill:#e8f5e9,stroke:#388e3c\n```\n\n**다음 장에서는**:\n- 기획서대로 하드웨어 연결하기\n- 단계별로 코드 작성하기\n- 기능 통합하고 테스트하기\n\n기획서 잘 보관하세요! 다음 시간에 그대로 가져와야 해요! 📄✨",
      "tokens_used": 18331,
      "input_tokens": 13376,
      "output_tokens": 4955
    },
    {
      "success": true,
      "chapter_id": "chapter17",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter17.md",
      "content": "# Chapter 17: 만들기 - 회로 구성과 코딩\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 설계서를 보고 실제 회로를 구성할 수 있다\n- [ ] 여러 기능을 하나의 프로그램으로 통합할 수 있다\n- [ ] 오류를 체계적으로 찾아 해결하는 디버깅을 할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n지난 시간에 열심히 기획서를 작성했죠? 이제 **진짜 만들 시간**입니다! 🎉\n\n설계도만 있으면 집이 저절로 지어지지 않듯, 기획서만 있다고 스마트 기기가 완성되지 않아요. 직접 부품을 연결하고, 코드를 작성하고, 테스트해야 합니다.\n\n여기서 중요한 건 **문제가 생겨도 당황하지 않는 것**이에요. 프로 개발자들도 코드 작성 시간보다 **디버깅 시간**이 더 길다고 해요. 오류를 만나고 해결하는 과정에서 진짜 실력이 쌓입니다!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 단계별 개발 전략\n\n프로젝트를 만들 때 한 번에 모든 걸 완성하려고 하면 어디서 문제가 생겼는지 찾기 어려워요.\n\n1. **비유로 시작**: \"마치 요리할 때 재료를 하나씩 맛보며 확인하는 것처럼, 코드도 조금씩 테스트하며 만들어요\"\n2. **정확한 정의**: \"단계별 개발은 기능을 작은 단위로 나누어 각각 완성하고 테스트한 후, 하나씩 합치는 방법입니다\"\n3. **예시로 확인**: \"스마트 알람을 만든다면 ① LED만 테스트 → ② 부저만 테스트 → ③ 센서만 테스트 → ④ 합치기\"\n\n**쉽게 말하면**: 작게 나눠서 각각 성공시킨 후, 하나씩 합쳐요!\n\n### 개념 2: 디버깅의 기본 원칙\n\n```mermaid\nflowchart LR\n    A[🐛 오류 발생] --> B[🔍 에러 메시지 읽기]\n    B --> C[📍 문제 위치 찾기]\n    C --> D[🧪 가설 세우기]\n    D --> E[✅ 수정 후 테스트]\n    E -->|해결!| F[🎉 성공]\n    E -->|아직...| D\n    \n    style A fill:#ffebee,stroke:#c62828\n    style B fill:#fff3e0,stroke:#ef6c00\n    style C fill:#e3f2fd,stroke:#1565c0\n    style D fill:#f3e5f5,stroke:#7b1fa2\n    style E fill:#e8f5e9,stroke:#2e7d32\n    style F fill:#e8f5e9,stroke:#2e7d32\n```\n\n1. **비유로 시작**: \"의사가 증상을 듣고 원인을 찾듯, 에러 메시지는 컴퓨터가 알려주는 '증상'이에요\"\n2. **정확한 정의**: \"디버깅은 프로그램의 오류(버그)를 찾아 수정하는 과정입니다\"\n3. **예시로 확인**: \"'NameError: name 'led' is not defined'는 'led라는 이름을 모르겠어요'라는 뜻이에요\"\n\n**쉽게 말하면**: 에러 메시지를 친구처럼 대해요 - 뭐가 문제인지 알려주거든요!\n\n### 개념 3: 코드 통합의 핵심\n\n여러 기능을 합칠 때 가장 중요한 건 **핀 충돌 방지**와 **변수명 정리**예요.\n\n```mermaid\nflowchart TB\n    subgraph 통합 전\n        A1[LED 코드<br/>led = Pin 16] \n        A2[버튼 코드<br/>btn = Pin 16]\n    end\n    \n    subgraph 통합 후\n        B1[LED: Pin 18] \n        B2[버튼: Pin 16]\n    end\n    \n    A1 --> |⚠️ 핀 충돌!| C[오류 발생]\n    통합전 --> |핀 정리| 통합후\n    통합후 --> D[✅ 정상 작동]\n    \n    style C fill:#ffcdd2,stroke:#c62828\n    style D fill:#c8e6c9,stroke:#2e7d32\n```\n\n**쉽게 말하면**: 같은 핀을 두 번 사용하면 안 돼요!\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 기획서 점검하기\n\n**목표**: 만들기 전에 필요한 것들 확인하기\n\n시작하기 전에 기획서를 다시 펼쳐보세요:\n\n**✅ 체크리스트**\n- [ ] 사용할 센서/출력장치 목록이 있나요?\n- [ ] 각 부품의 연결 포트가 정해졌나요?\n- [ ] 핀 번호가 겹치는 건 없나요?\n\n📌 **예시 - 스마트 알람 기획서 요약**\n\n| 부품 | 역할 | 연결 포트 | 핀 번호 |\n|------|------|----------|---------|\n| DHT11 | 온도 감지 | D16 | GP16 |\n| LED | 상태 표시 | D18 | GP18 |\n| 부저 | 알람 소리 | D20 | GP20 |\n| 버튼 | 알람 끄기 | D17 | GP17 |\n\n### Step 2: 부품 하나씩 테스트하기\n\n**목표**: 각 부품이 제대로 작동하는지 개별 확인\n\n**🔴 LED 테스트 코드**:\n```python\n# === WHAT: LED가 잘 연결됐는지 테스트 ===\n# 먼저 LED만 따로 테스트해봐요\n\n# --- WHY: 나중에 문제 생기면 어디가 문제인지 모르니까 ---\n# 지금 확인해두면 통합할 때 편해요\n\n# HOW: 어떻게 동작하는지\nfrom machine import Pin  # 핀 제어 라이브러리\nimport time              # 시간 함수\n\nled = Pin(18, Pin.OUT)   # GP18에 LED 연결\n\n# 3번 깜빡여서 확인\nfor i in range(3):\n    led.on()             # LED 켜기\n    print(\"LED 켜짐\")\n    time.sleep(0.5)      # 0.5초 대기\n    led.off()            # LED 끄기\n    print(\"LED 꺼짐\")\n    time.sleep(0.5)\n\nprint(\"LED 테스트 완료! ✅\")\n```\n\n**실행 결과**:\n```\nLED 켜짐\nLED 꺼짐\nLED 켜짐\nLED 꺼짐\nLED 켜짐\nLED 꺼짐\nLED 테스트 완료! ✅\n```\n\n**여기서 잠깐! 🤔**\nLED가 깜빡이지 않는다면? \n1. Grove 케이블이 제대로 꽂혔는지 확인\n2. 포트 번호(D18)가 맞는지 확인\n3. LED 모듈의 방향이 맞는지 확인\n\n**🔔 부저 테스트 코드**:\n```python\n# === WHAT: 부저가 잘 작동하는지 테스트 ===\nfrom machine import Pin, PWM\nimport time\n\nbuzzer = PWM(Pin(20))    # GP20에 부저 연결\n\n# 삐~ 소리 한 번\nbuzzer.freq(1000)        # 1000Hz 주파수\nbuzzer.duty_u16(32768)   # 50% 듀티 (소리 켜기)\nprint(\"삐~ 소리 나나요?\")\ntime.sleep(0.5)\nbuzzer.duty_u16(0)       # 소리 끄기\n\nprint(\"부저 테스트 완료! ✅\")\n```\n\n**🌡️ DHT11 센서 테스트 코드**:\n```python\n# === WHAT: 온습도 센서 테스트 ===\nfrom machine import Pin\nimport dht\nimport time\n\nsensor = dht.DHT11(Pin(16))  # GP16에 DHT11 연결\n\n# 3번 측정해보기\nfor i in range(3):\n    time.sleep(2)            # DHT11은 2초 간격 필요\n    sensor.measure()         # 측정 실행\n    temp = sensor.temperature()  # 온도 읽기\n    humid = sensor.humidity()    # 습도 읽기\n    print(f\"#{i+1} 온도: {temp}°C, 습도: {humid}%\")\n\nprint(\"센서 테스트 완료! ✅\")\n```\n\n### Step 3: 기능 통합하기\n\n**목표**: 테스트한 부품들을 하나의 프로그램으로 합치기\n\n```python\n# === WHAT: 스마트 알람 - 통합 버전 ===\n# 온도가 높으면 부저가 울리고 LED가 켜져요\n\n# --- WHY: 각각 성공한 코드를 하나로 합쳐요 ---\n# 이미 테스트했으니 자신있게!\n\nfrom machine import Pin, PWM\nimport dht\nimport time\n\n# === 1단계: 모든 부품 초기화 ===\nprint(\"부품 초기화 중...\")\nsensor = dht.DHT11(Pin(16))  # 온습도 센서\nled = Pin(18, Pin.OUT)        # LED\nbuzzer = PWM(Pin(20))         # 부저\nbutton = Pin(17, Pin.IN, Pin.PULL_DOWN)  # 버튼\n\n# 알람 기준 온도\nALARM_TEMP = 28\n\n# === 2단계: 알람 함수 만들기 ===\ndef alarm_on():\n    \"\"\"알람을 켜는 함수\"\"\"\n    led.on()\n    buzzer.freq(1000)\n    buzzer.duty_u16(32768)\n    print(\"🚨 알람 켜짐!\")\n\ndef alarm_off():\n    \"\"\"알람을 끄는 함수\"\"\"\n    led.off()\n    buzzer.duty_u16(0)\n    print(\"알람 꺼짐\")\n\n# === 3단계: 메인 루프 ===\nprint(f\"스마트 알람 시작! (기준 온도: {ALARM_TEMP}°C)\")\nprint(\"버튼을 누르면 알람이 꺼져요\")\n\nalarm_active = False  # 알람 상태\n\nwhile True:\n    # 온도 측정\n    try:\n        sensor.measure()\n        temp = sensor.temperature()\n        print(f\"현재 온도: {temp}°C\")\n        \n        # 온도가 높으면 알람\n        if temp >= ALARM_TEMP and not alarm_active:\n            alarm_on()\n            alarm_active = True\n            \n    except Exception as e:\n        print(f\"센서 오류: {e}\")\n    \n    # 버튼으로 알람 끄기\n    if button.value() == 1 and alarm_active:\n        alarm_off()\n        alarm_active = False\n    \n    time.sleep(2)  # 2초마다 체크\n```\n\n**여기서 잠깐! 🤔**\n`try-except`는 오류가 나도 프로그램이 멈추지 않게 해줘요. 센서가 가끔 읽기 실패할 수 있거든요!\n\n---\n\n## 📝 전체 코드\n\n```python\n# === 스마트 알람 시스템 v1.0 ===\n# 온도 기반 알람 + 버튼으로 끄기\n# 만든이: ____________\n# 날짜: ____________\n\nfrom machine import Pin, PWM\nimport dht\nimport time\n\n# ========== 설정값 ==========\nALARM_TEMP = 28      # 알람 기준 온도\nCHECK_INTERVAL = 2   # 측정 간격(초)\n\n# ========== 부품 초기화 ==========\nsensor = dht.DHT11(Pin(16))\nled = Pin(18, Pin.OUT)\nbuzzer = PWM(Pin(20))\nbutton = Pin(17, Pin.IN, Pin.PULL_DOWN)\n\n# ========== 함수 정의 ==========\ndef alarm_on():\n    led.on()\n    buzzer.freq(1000)\n    buzzer.duty_u16(32768)\n    print(\"🚨 알람 작동!\")\n\ndef alarm_off():\n    led.off()\n    buzzer.duty_u16(0)\n    print(\"✅ 알람 해제\")\n\ndef read_temperature():\n    try:\n        sensor.measure()\n        return sensor.temperature()\n    except:\n        return None\n\n# ========== 메인 프로그램 ==========\nprint(\"=\" * 30)\nprint(\"  스마트 알람 시스템 시작\")\nprint(f\"  기준 온도: {ALARM_TEMP}°C\")\nprint(\"=\" * 30)\n\nalarm_active = False\n\nwhile True:\n    temp = read_temperature()\n    \n    if temp is not None:\n        print(f\"온도: {temp}°C\", end=\" \")\n        \n        if temp >= ALARM_TEMP and not alarm_active:\n            alarm_on()\n            alarm_active = True\n        elif temp < ALARM_TEMP:\n            print(\"- 정상\")\n    else:\n        print(\"센서 읽기 실패\")\n    \n    if button.value() == 1 and alarm_active:\n        alarm_off()\n        alarm_active = False\n    \n    time.sleep(CHECK_INTERVAL)\n```\n\n---\n\n## ⚠️ 자주 하는 실수\n\n### 실수 1: 같은 핀을 두 번 사용\n\n**증상**: \n```\nValueError: Pin 16 already in use\n```\n\n**원인**: 두 개의 부품을 같은 핀에 연결하려고 함\n\n**해결**:\n```python\n# 잘못된 코드\nled = Pin(16, Pin.OUT)\nsensor = dht.DHT11(Pin(16))  # 충돌!\n\n# 올바른 코드\nled = Pin(18, Pin.OUT)       # LED는 18번\nsensor = dht.DHT11(Pin(16))  # 센서는 16번\n```\n\n### 실수 2: 변수명 오타\n\n**증상**: \n```\nNameError: name 'buzer' is not defined\n```\n\n**원인**: 변수 이름을 다르게 씀 (buzzer vs buzer)\n\n**해결**:\n```python\n# 잘못된 코드\nbuzzer = PWM(Pin(20))\nbuzer.freq(1000)      # 오타!\n\n# 올바른 코드\nbuzzer = PWM(Pin(20))\nbuzzer.freq(1000)     # 정확한 이름\n```\n\n### 실수 3: 들여쓰기 오류\n\n**증상**: \n```\nIndentationError: unexpected indent\n```\n\n**원인**: 들여쓰기(스페이스)가 맞지 않음\n\n**해결**:\n```python\n# 잘못된 코드\nif temp > 28:\nprint(\"덥다!\")        # 들여쓰기 없음\n\n# 올바른 코드  \nif temp > 28:\n    print(\"덥다!\")    # 4칸 들여쓰기\n```\n\n### 실수 4: 센서 측정 간격 무시\n\n**증상**: 온도가 항상 이상한 값이 나옴\n\n**원인**: DHT11은 최소 2초 간격이 필요\n\n**해결**:\n```python\n# 잘못된 코드\nwhile True:\n    sensor.measure()\n    print(sensor.temperature())\n    time.sleep(0.5)   # 너무 빨라!\n\n# 올바른 코드\nwhile True:\n    sensor.measure()\n    print(sensor.temperature())\n    time.sleep(2)     # 2초 이상!\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n1. **왜 부품을 하나씩 테스트한 후에 통합해야 할까요?**\n\n2. **`try-except`를 쓰는 이유는 무엇인가요?**\n\n3. **다음 에러 메시지의 의미는?**\n   ```\n   NameError: name 'sensor' is not defined\n   ```\n\n<details>\n<summary>정답 확인</summary>\n\n1. 문제가 생겼을 때 어디서 발생했는지 쉽게 찾을 수 있어요. 모두 합쳐놓으면 원인 찾기가 어려워요.\n\n2. 오류가 나도 프로그램이 멈추지 않고 계속 실행되게 해줘요. 센서는 가끔 읽기 실패할 수 있거든요.\n\n3. 'sensor'라는 변수를 정의하지 않고 사용했다는 뜻이에요. `sensor = dht.DHT11(Pin(16))` 같은 코드가 필요해요.\n\n</details>\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: LED 패턴 바꾸기\n알람이 울릴 때 LED가 깜빡이도록 수정해보세요.\n\n### 도전 2: 온도 단계별 반응\n- 28°C 이상: 빨간 LED\n- 25~28°C: 노란 LED  \n- 25°C 미만: 초록 LED\n\n### 도전 3: OLED에 상태 표시 ⭐\n현재 온도와 알람 상태를 OLED 화면에 표시해보세요!\n\n---\n\n## 🛠️ 문제 해결 가이드\n\n문제가 생겼을 때 이 순서로 확인하세요:\n\n```mermaid\nflowchart TD\n    A[문제 발생!] --> B{에러 메시지<br/>있나요?}\n    B -->|있음| C[메시지 읽기]\n    B -->|없음| D[print로 확인]\n    \n    C --> E[어느 줄인지 확인]\n    E --> F[그 줄 주변 점검]\n    \n    D --> G[의심 구간에<br/>print 추가]\n    G --> H[값 확인]\n    \n    F --> I[수정 후 테스트]\n    H --> I\n    \n    style A fill:#ffcdd2,stroke:#c62828\n    style I fill:#c8e6c9,stroke:#2e7d32\n```\n\n**💡 디버깅 꿀팁**\n- `print()`를 자주 써서 값을 확인하세요\n- 문제가 생기면 주석(`#`)으로 코드를 잠시 비활성화해보세요\n- 작동하던 코드로 돌아가서 천천히 다시 시도하세요\n\n---\n\n## 🔗 다음 장으로\n\n축하해요! 🎉 설계서를 바탕으로 실제 작동하는 기기를 만들었어요!\n\n**이번 장에서 배운 것**:\n- 단계별 개발로 안전하게 만들기\n- 부품 개별 테스트의 중요성\n- 에러 메시지 읽고 해결하기\n- 코드 통합 시 주의점\n\n**다음 장 예고**: \n완성된 프로젝트를 **테스트하고 발표**하는 시간이에요! 내 작품을 멋지게 소개하는 방법, 친구들 작품에서 배우는 법을 익혀봅시다. 최종 점검 후 자랑스럽게 발표해봐요! 🏆",
      "tokens_used": 19287,
      "input_tokens": 13385,
      "output_tokens": 5902
    },
    {
      "success": true,
      "chapter_id": "chapter18",
      "file_path": "/Users/greatsong/greatsong-project/data-ai-book/projects/pico-basic/docs/chapter18.md",
      "content": "# 발표와 공유 - 프로젝트 시연\n\n## 🎯 이 장에서 배우는 것\n\n- [ ] 완성된 프로젝트를 청중 앞에서 시연할 수 있다\n- [ ] 개발 과정과 배운 점을 논리적으로 설명할 수 있다\n- [ ] 다른 사람의 프로젝트를 보고 건설적인 피드백을 줄 수 있다\n- [ ] 6주간의 학습 여정을 정리하고 다음 단계를 계획할 수 있다\n\n---\n\n## 💡 왜 이걸 배우나요?\n\n> **\"좋은 프로젝트도 발표를 못하면 절반만 완성된 것이다\"**\n\n여러분이 만든 프로젝트는 정말 대단해요! 하지만 아무리 좋은 작품도 다른 사람에게 설명하지 못하면 그 가치가 절반으로 줄어들어요.\n\n**실제 개발자들의 일상**을 생각해보세요:\n- 🎤 **스타트업**: 투자자에게 아이디어를 피칭해야 해요\n- 👥 **회사**: 팀원들에게 자신이 만든 기능을 설명해야 해요\n- 🌐 **오픈소스**: 전 세계 개발자에게 프로젝트를 소개해야 해요\n\n발표 능력은 **코딩 실력만큼 중요한 개발자의 필수 역량**이에요. 오늘 배운 것을 앞으로 수많은 발표에 활용할 수 있을 거예요!\n\n---\n\n## 📚 핵심 개념\n\n### 개념 1: 효과적인 기술 발표\n\n1. **비유로 시작**: 기술 발표는 마치 **영화 예고편**과 같아요. 짧은 시간 안에 핵심을 보여주고, 관객이 \"와, 이거 대박이다!\"라고 느끼게 만들어야 해요.\n\n2. **정확한 정의**: 기술 발표란 자신이 만든 프로젝트의 **목적, 기능, 기술적 특징**을 청중이 이해할 수 있도록 설명하고 시연하는 것입니다.\n\n3. **예시로 확인**: \"저는 온도에 따라 자동으로 색이 변하는 스마트 무드등을 만들었어요. DHT20 센서로 온도를 읽고, RGB LED로 색을 표현합니다.\"\n\n**쉽게 말하면**: 내가 뭘 만들었고, 왜 만들었고, 어떻게 작동하는지 보여주는 것!\n\n---\n\n### 개념 2: 피드백의 기술\n\n1. **비유로 시작**: 좋은 피드백은 **거울**과 같아요. 상대방이 보지 못한 것을 비춰주되, 깨트리지 않고 함께 더 나은 모습을 찾아가는 거예요.\n\n2. **정확한 정의**: 건설적인 피드백이란 상대방의 작품에서 **좋은 점을 인정**하고, **개선 가능한 부분을 구체적으로 제안**하는 것입니다.\n\n3. **예시로 확인**: \n   - ❌ \"별로예요\" (구체적이지 않음)\n   - ✅ \"LED 반응이 빨라서 좋았어요! 소리 피드백도 추가하면 더 재밌을 것 같아요\"\n\n**쉽게 말하면**: 칭찬 + 구체적인 개선 아이디어 = 좋은 피드백!\n\n---\n\n### 개념 3: 메이커의 성장 마인드셋\n\n```mermaid\nflowchart LR\n    A[🌱 아이디어] --> B[🔨 시도]\n    B --> C[❌ 실패]\n    C --> D[📚 학습]\n    D --> B\n    B --> E[✅ 성공]\n    E --> F[🚀 공유]\n    F --> A\n    \n    style A fill:#e8f5e9,stroke:#388e3c\n    style B fill:#fff3e0,stroke:#f57c00\n    style C fill:#ffebee,stroke:#d32f2f\n    style D fill:#e3f2fd,stroke:#1976d2\n    style E fill:#e8f5e9,stroke:#388e3c\n    style F fill:#f3e5f5,stroke:#7b1fa2\n```\n\n**메이커 문화의 핵심**:\n- 🔄 **반복**: 실패는 배움의 기회\n- 🤝 **공유**: 서로의 지식을 나누며 성장\n- 🎯 **도전**: 완벽보다 시작이 중요\n\n---\n\n## 🔨 따라하기\n\n### Step 1: 발표 준비하기\n\n**목표**: 3분 발표를 위한 구조를 만들어봐요.\n\n**발표 구조 템플릿**:\n\n```\n🎯 1. 소개 (30초)\n   - 프로젝트 이름\n   - 한 문장 설명\n\n💡 2. 동기 (30초)\n   - 왜 만들었나요?\n   - 어떤 문제를 해결하나요?\n\n⚙️ 3. 시연 (1분)\n   - 핵심 기능 보여주기\n   - 센서/출력 장치 설명\n\n🔧 4. 기술 설명 (30초)\n   - 사용한 부품\n   - 어려웠던 점과 해결 방법\n\n🚀 5. 마무리 (30초)\n   - 배운 점\n   - 향후 개선 계획\n```\n\n**여기서 잠깐! 🤔**\n\n발표할 때 가장 중요한 건 **시연이 잘 작동하는 것**이에요! 발표 전에 반드시 코드가 정상 작동하는지 확인하세요.\n\n---\n\n### Step 2: 발표 스크립트 작성하기\n\n**목표**: 실제로 말할 내용을 정리해봐요.\n\n**예시 스크립트** (스마트 무드등 프로젝트):\n\n```\n안녕하세요! 저는 \"온도로 감정을 표현하는 스마트 무드등\"을 \n만들었습니다.\n\n요즘 책상에서 공부할 때 너무 덥거나 추운지 잘 모를 때가 있어서,\n온도를 색으로 알려주는 조명을 만들고 싶었어요.\n\n[시연 시작]\n지금 온도는 25도예요. 보시면 초록색이 켜져 있죠?\n손으로 센서를 감싸면... 온도가 올라가면서 주황색으로 바뀝니다!\n\nDHT20 온습도 센서와 RGB LED를 사용했고,\n가장 어려웠던 건 온도 범위에 따라 색을 자연스럽게 바꾸는 것이었어요.\n여러 번 테스트해서 지금의 값을 찾았습니다.\n\n이 프로젝트를 통해 센서 데이터를 시각화하는 방법을 배웠고,\n다음에는 스마트폰으로 색상을 조절하는 기능을 추가하고 싶어요.\n\n감사합니다!\n```\n\n---\n\n### Step 3: 피드백 카드 작성하기\n\n**목표**: 다른 친구들의 발표를 듣고 피드백을 작성해봐요.\n\n**피드백 카드 양식**:\n\n```\n📋 피드백 카드\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n발표자: ________________\n프로젝트명: ________________\n\n⭐ 좋았던 점 (2가지 이상)\n1. ________________________________\n2. ________________________________\n\n💡 개선 아이디어 (1가지)\n________________________________\n________________________________\n\n🎯 한 줄 응원\n________________________________\n\n피드백 작성자: ________________\n```\n\n**좋은 피드백 예시**:\n- ⭐ \"OLED에 아이콘을 표시한 게 직관적이었어요!\"\n- ⭐ \"버튼으로 모드를 바꾸는 기능이 실용적이에요!\"\n- 💡 \"소리로도 알려주면 눈을 안 봐도 될 것 같아요\"\n- 🎯 \"완전 상품화해도 될 것 같아요! 대단해요!\"\n\n---\n\n## 📝 발표 체크리스트\n\n발표 전 최종 점검!\n\n```python\n# === 발표 준비 체크리스트 ===\n\n준비물_체크 = {\n    \"피코와 센서 연결 확인\": False,\n    \"코드가 정상 작동\": False,\n    \"USB 케이블 여분\": False,\n    \"발표 스크립트 숙지\": False,\n    \"3분 이내 연습 완료\": False,\n}\n\ndef 최종_점검():\n    미완료 = [항목 for 항목, 완료 in 준비물_체크.items() if not 완료]\n    \n    if 미완료:\n        print(\"⚠️ 아직 준비가 덜 됐어요!\")\n        for 항목 in 미완료:\n            print(f\"  □ {항목}\")\n    else:\n        print(\"✅ 완벽해요! 발표 준비 완료!\")\n        print(\"🎤 자신감을 가지고 발표하세요!\")\n\n# 여러분의 체크리스트를 True로 바꿔보세요!\n```\n\n---\n\n## 🏆 6주간의 여정 돌아보기\n\n### 우리가 함께 배운 것들\n\n```mermaid\nflowchart TB\n    subgraph Part1[\"📦 Part 1-2: 피코 기초\"]\n        A1[피코 시작하기]\n        A2[LED 제어]\n        A3[버튼 입력]\n    end\n    \n    subgraph Part2[\"🔧 Part 3: 센서와 출력\"]\n        B1[온습도 센서]\n        B2[조도 센서]\n        B3[RGB LED]\n        B4[부저와 서보]\n    end\n    \n    subgraph Part3[\"📡 Part 4: 네트워크\"]\n        C1[WiFi 연결]\n        C2[NTP 시간]\n        C3[날씨 API]\n    end\n    \n    subgraph Part4[\"🎨 Part 5-6: 프로젝트\"]\n        D1[OLED 디스플레이]\n        D2[통합 프로젝트]\n        D3[발표와 공유]\n    end\n    \n    Part1 --> Part2 --> Part3 --> Part4\n    \n    style A1 fill:#e3f2fd,stroke:#1976d2\n    style A2 fill:#e3f2fd,stroke:#1976d2\n    style A3 fill:#e3f2fd,stroke:#1976d2\n    style B1 fill:#fff3e0,stroke:#f57c00\n    style B2 fill:#fff3e0,stroke:#f57c00\n    style B3 fill:#fff3e0,stroke:#f57c00\n    style B4 fill:#fff3e0,stroke:#f57c00\n    style C1 fill:#e8f5e9,stroke:#388e3c\n    style C2 fill:#e8f5e9,stroke:#388e3c\n    style C3 fill:#e8f5e9,stroke:#388e3c\n    style D1 fill:#f3e5f5,stroke:#7b1fa2\n    style D2 fill:#f3e5f5,stroke:#7b1fa2\n    style D3 fill:#f3e5f5,stroke:#7b1fa2\n```\n\n---\n\n## ⚠️ 발표할 때 자주 하는 실수\n\n### 실수 1: 너무 기술적인 설명만 하기\n\n**증상**: 청중이 멍한 표정을 지음\n\n**원인**: 코드 설명에만 집중하고 \"왜 만들었는지\"를 빠뜨림\n\n**해결**:\n```\n❌ \"Pin 16에 DHT20을 연결하고 read() 함수로 값을 읽어서...\"\n\n✅ \"방이 너무 더운지 추운지 색으로 알려주는 조명이에요!\n   보시면 지금 초록색이죠? 온도가 적당하다는 뜻이에요.\"\n```\n\n---\n\n### 실수 2: 시연이 작동하지 않을 때 당황하기\n\n**증상**: \"어... 아까는 됐는데...\" 하며 멈춤\n\n**원인**: 예상치 못한 오류, 연결 문제\n\n**해결**:\n```\n미리 준비한 말:\n\"잠깐 연결 문제가 있네요. 다시 연결해볼게요!\"\n(침착하게 USB 재연결)\n\n또는:\n\"시연 영상을 준비했는데, 먼저 보여드릴게요!\"\n(백업 영상 재생)\n```\n\n**팁**: 발표 전 영상으로 작동 모습을 찍어두세요! 📱\n\n---\n\n### 실수 3: 시간 초과\n\n**증상**: \"아, 시간이 벌써...\" 하며 급하게 마무리\n\n**원인**: 연습 부족, 너무 많은 내용\n\n**해결**:\n```\n발표 연습 방법:\n1. 스톱워치 켜고 혼자 연습 (3번 이상)\n2. 3분을 넘기면 과감히 내용 줄이기\n3. 핵심 기능 1-2개만 시연하기\n\n기억하세요:\n\"모든 걸 보여주려 하지 마세요. \n 가장 자신 있는 것 하나만 확실히!\"\n```\n\n---\n\n## ✅ 스스로 점검하기\n\n### 발표 준비 점검\n\n1. **사실 확인**: 좋은 기술 발표의 5가지 구성요소는 무엇인가요?\n\n2. **적용 질문**: 여러분의 프로젝트를 한 문장으로 설명해보세요.\n\n3. **이유 질문**: 피드백을 줄 때 \"좋았던 점\"을 먼저 말하는 이유는 무엇일까요?\n\n<details>\n<summary>정답 확인</summary>\n\n1. **5가지 구성요소**: 소개, 동기, 시연, 기술 설명, 마무리\n\n2. **한 문장 설명 예시**: \n   - \"온도에 따라 색이 변하는 스마트 무드등\"\n   - \"거리에 따라 소리가 변하는 악기\"\n   - \"시간과 날씨를 알려주는 IoT 시계\"\n\n3. **이유**: 먼저 긍정적인 분위기를 만들면 상대방이 개선 피드백도 열린 마음으로 받아들일 수 있어요. 또한 본인도 몰랐던 장점을 발견하게 해줘요!\n\n</details>\n\n---\n\n## 🎓 수료를 축하합니다!\n\n> ### 🏅 피지컬 컴퓨팅 과정 수료 인증\n> \n> **수료자**: ________________\n> \n> **과정명**: 피코와 친해지기 - 피지컬 컴퓨팅 입문\n> \n> **기간**: 총 18차시 (36시간)\n> \n> #### 📚 학습 내용\n> - ✅ 라즈베리파이 피코 프로그래밍\n> - ✅ 센서와 액추에이터 제어\n> - ✅ 네트워크 연결과 API 활용\n> - ✅ 통합 프로젝트 설계 및 구현\n> \n> **\"이제 당신은 무엇이든 만들 수 있는 메이커입니다!\"** 🚀\n\n---\n\n## 🚀 더 해보기\n\n### 도전 1: 프로젝트 문서화하기 📝\nGitHub에 프로젝트를 올려보세요!\n- README.md 작성\n- 회로 연결 사진\n- 코드 설명\n\n### 도전 2: 개선 버전 만들기 🔧\n피드백을 반영해서 프로젝트를 업그레이드해보세요.\n- 새로운 기능 추가\n- 버그 수정\n- UI 개선\n\n### 도전 3: 다른 사람 가르쳐보기 👨‍🏫 ⭐\n친구나 가족에게 피코 사용법을 알려주세요!\n- 가르치면서 더 깊이 이해하게 돼요\n- 질문을 받으면 새로운 관점을 얻어요\n\n---\n\n## 🔗 앞으로의 여정\n\n### 🌟 여러분이 이룬 것\n```\n시작: \"피코가 뭐예요?\"\n     ↓\n지금: \"내가 만든 스마트 기기가 작동해요!\"\n```\n\n### 🗺️ 다음 단계 추천\n\n```mermaid\nflowchart LR\n    A[🎓 수료!] --> B{다음 선택}\n    B --> C[📡 IoT 심화]\n    B --> D[🤖 로봇공학]\n    B --> E[🧠 AI/ML]\n    B --> F[📱 앱 개발]\n    \n    C --> G[스마트홈 프로젝트]\n    D --> H[자율주행 로봇]\n    E --> I[TinyML 학습]\n    F --> J[블루투스 앱 연동]\n    \n    style A fill:#f3e5f5,stroke:#7b1fa2\n    style C fill:#e3f2fd,stroke:#1976d2\n    style D fill:#fff3e0,stroke:#f57c00\n    style E fill:#e8f5e9,stroke:#388e3c\n    style F fill:#ffebee,stroke:#d32f2f\n```\n\n### 💬 기억해주세요\n\n> **\"완벽하지 않아도 괜찮아요. 시작했다는 것 자체가 대단한 거예요!\"**\n\n프로젝트가 100% 완성되지 않았어도, 작동하지 않는 부분이 있어도 괜찮아요. 중요한 건 **시도하고, 배우고, 공유하는 것**이에요.\n\n여러분은 이제 **아이디어를 현실로 만들 수 있는 메이커**가 되었어요. 앞으로 어떤 멋진 것들을 만들게 될지 정말 기대돼요! 🚀\n\n---\n\n## 📋 마지막 활동: 성장 일지 작성\n\n```\n📝 나의 피지컬 컴퓨팅 성장 일지\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n1. 가장 기억에 남는 순간\n   _________________________________\n\n2. 가장 어려웠던 것과 해결 방법\n   _________________________________\n\n3. 가장 뿌듯했던 순간\n   _________________________________\n\n4. 앞으로 만들고 싶은 것\n   _________________________________\n\n5. 미래의 나에게 한마디\n   _________________________________\n\n작성일: ___년 ___월 ___일\n서명: ________________\n```\n\n---\n\n**🎉 18차시 수업을 모두 완료했습니다!**\n\n여러분의 도전과 성장에 박수를 보냅니다! 👏",
      "tokens_used": 19344,
      "input_tokens": 13398,
      "output_tokens": 5946
    }
  ],
  "errors": [],
  "total_tokens": 338991,
  "total_input_tokens": 240571,
  "total_output_tokens": 98420,
  "estimated_cost": {
    "input_cost": 3.6086,
    "output_cost": 7.3815,
    "total_cost": 10.9901,
    "pricing": {
      "input": 15.0,
      "output": 75.0
    }
  },
  "elapsed_time": 319.851477,
  "generated_at": "2026-02-05T10:31:23.249771",
  "model": "claude-opus-4-5-20251101"
}